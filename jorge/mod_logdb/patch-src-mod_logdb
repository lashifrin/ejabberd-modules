--- mod_logdb.erl.orig	Wed Jun 13 10:26:33 2007
+++ mod_logdb.erl	Wed Jun 13 10:26:31 2007
@@ -0,0 +1,885 @@
+%%%----------------------------------------------------------------------
+%%% File    : mod_logdb.erl
+%%% Author  : Oleg Palij (mailto:o.palij@dp.uz.gov.ua xmpp://malik@jabber.te.ua)
+%%% Purpose : Log user messages to db
+%%% Version : trunk
+%%% Url     : http://www.dp.uz.gov.ua/o.palij/mod_logdb/
+%%%----------------------------------------------------------------------
+
+-module(mod_logdb).
+-author('').
+-vsn('').
+
+-behaviour(gen_server).
+-behaviour(gen_mod).
+
+% supervisor
+-export([start_link/2]).
+% gen_server
+-export([start/2,stop/1,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2]).
+% hooks
+-export([send_packet/3, receive_packet/4]).
+% ejabberdctl
+-export([rebuild_stats/3,
+         copy_messages/1, copy_messages_ctl/3, copy_messages_int_tc/1]).
+%
+-export([get_vhost_stats/1, get_vhost_stats_at/2,
+         get_user_stats/2, get_user_messages_at/3,
+         get_dates/1,
+         sort_stats/1,
+         convert_timestamp/1, convert_timestamp_brief/1,
+         get_user_settings/2, set_user_settings/3,
+         user_messages_at_parse_query/4, user_messages_parse_query/3,
+         vhost_messages_parse_query/2, vhost_messages_at_parse_query/4,
+         list_to_bool/1, bool_to_list/1]).
+
+-include("mod_logdb.hrl").
+-include("ejabberd.hrl").
+-include("jlib.hrl").
+-include("ejabberd_ctl.hrl").
+
+-define(PROCNAME, ejabberd_mod_logdb).
+
+-record(state, {vhost, dbmod, monref, dbopts, dbs, default_to_log, ignore_jids, groupchat, purge_older_days, poll_users_settings}).
+
+ets_settings_table(VHost) -> list_to_atom("logdb_settings_" ++ VHost).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_mod/gen_server callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% ejabberd starts module
+start(VHost, Opts) ->
+    ChildSpec =
+        {gen_mod:get_module_proc(VHost, ?PROCNAME),
+         {?MODULE, start_link, [VHost, Opts]},
+         permanent,
+         1000,
+         worker,
+         [?MODULE]},
+    % add child to ejabberd_sup
+    supervisor:start_child(ejabberd_sup, ChildSpec).
+
+% supervisor starts gen_server
+start_link(VHost, Opts) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:start_link({local, Proc}, ?MODULE, [VHost, Opts], []).
+
+init([VHost, Opts]) ->
+    process_flag(trap_exit, true),
+    DBs = gen_mod:get_opt(dbs, Opts, [{mnesia, []}]),
+    VHostDB = gen_mod:get_opt(vhosts, Opts, [{VHost, mnesia}]),
+    % 10 is default becouse of using in clustered environment
+    PollUsersSettings = gen_mod:get_opt(poll_users_settings, Opts, 10),
+
+    {value,{_, DBName}} = lists:keysearch(VHost, 1, VHostDB),
+    {value, {DBName, DBOpts}} = lists:keysearch(DBName, 1, DBs),
+
+    ?MYDEBUG("Starting mod_logdb for ~p with ~p backend", [VHost, DBName]),
+
+    DBMod = list_to_atom(atom_to_list(?MODULE) ++ "_" ++ atom_to_list(DBName)),
+
+    % actually all work begin on receiving start signal
+    timer:send_after(1000, start),
+
+    {ok, #state{vhost=VHost,
+                dbmod=DBMod,
+                dbopts=DBOpts,
+                % dbs used for convert messages from one backend to other
+                dbs=DBs,
+                default_to_log=gen_mod:get_opt(default_to_log, Opts, true),
+                ignore_jids=gen_mod:get_opt(ignore_jids, Opts, []),
+                groupchat=gen_mod:get_opt(groupchat, Opts, none),
+                purge_older_days=gen_mod:get_opt(purge_older_days, Opts, never),
+                poll_users_settings=PollUsersSettings}}.
+
+cleanup(#state{vhost=VHost} = State) ->
+    ?MYDEBUG("Stopping ~s for ~p", [?MODULE, VHost]),
+
+    %ets:delete(ets_settings_table(VHost)),
+
+    ejabberd_hooks:delete(user_send_packet, VHost, ?MODULE, send_packet, 90),
+    ejabberd_hooks:delete(user_receive_packet, VHost, ?MODULE, receive_packet, 90),
+    ?MYDEBUG("Removed hooks for ~p", [VHost]),
+
+    ejabberd_ctl:unregister_commands(VHost, [{"rebuild_stats", "rebuild mod_logdb module stats for vhost"}], ?MODULE, rebuild_stats),
+    Supported_backends = lists:flatmap(fun({Backend, _Opts}) ->
+                                            [atom_to_list(Backend), " "]
+                                       end, State#state.dbs),
+    ejabberd_ctl:unregister_commands(
+                           VHost,
+                           [{"copy_messages backend", "copy messages from backend to current backend. backends could be: " ++ Supported_backends }],
+                           ?MODULE, copy_messages_ctl),
+    ?MYDEBUG("Unregistered commands for ~p", [VHost]).
+
+stop(VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    %gen_server:call(Proc, {cleanup}),
+    %?MYDEBUG("Cleanup in stop finished!!!!", []),
+    %timer:sleep(10000),
+    ok = supervisor:terminate_child(ejabberd_sup, Proc),
+    ok = supervisor:delete_child(ejabberd_sup, Proc).
+
+handle_call({cleanup}, _From, State) ->
+    cleanup(State),
+    ?MYDEBUG("Cleanup finished!!!!!", []),
+    {reply, ok, State};
+handle_call({get_dates, {VHost}}, _From, State) ->
+    Reply = (State#state.dbmod):get_dates(VHost),
+    {reply, Reply, State};
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% ejabberd_web_admin callbacks
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+handle_call({delete_messages_by_user_at, {VHost, PMsgs, Date}}, _From, State) ->
+    Reply = (State#state.dbmod):delete_messages_by_user_at(VHost, PMsgs, Date),
+    {reply, Reply, State};
+handle_call({delete_all_messages_by_user_at, {User, VHost, Date}}, _From, State) ->
+    Reply = (State#state.dbmod):delete_all_messages_by_user_at(User, VHost, Date),
+    {reply, Reply, State};
+handle_call({delete_messages_table_at, {VHost, Date}}, _From, State) ->
+    Reply = (State#state.dbmod):delete_messages_table_at(VHost, Date),
+    {reply, Reply, State};
+handle_call({get_vhost_stats, {VHost}}, _From, State) ->
+    Reply = (State#state.dbmod):get_vhost_stats(VHost),
+    {reply, Reply, State};
+handle_call({get_vhost_stats_at, {VHost, Date}}, _From, State) ->
+    Reply = (State#state.dbmod):get_vhost_stats_at(VHost, Date),
+    {reply, Reply, State};
+handle_call({get_user_stats, {User, VHost}}, _From, State) ->
+    Reply = (State#state.dbmod):get_user_stats(User, VHost),
+    {reply, Reply, State};
+handle_call({get_user_messages_at, {User, VHost, Date}}, _From, State) ->
+    Reply = (State#state.dbmod):get_user_messages_at(User, VHost, Date),
+    {reply, Reply, State};
+handle_call({get_user_settings, {User}}, _From, State) ->
+    Reply = case ets:match_object(ets_settings_table(State#state.vhost),
+                                  #user_settings{owner_name=User, _='_'}) of
+                 [Set] -> Set;
+                 _ -> #user_settings{owner_name=User,
+                                     dolog_default=State#state.default_to_log,
+                                     dolog_list=[],
+                                     donotlog_list=[]}
+            end,
+    {reply, Reply, State};
+handle_call({set_user_settings, {User, GSet}}, _From, State) ->
+    Set = GSet#user_settings{owner_name=User},
+    case ets:match_object(ets_settings_table(State#state.vhost),
+                          #user_settings{owner_name=User, _='_'}) of
+         [Set] ->
+             ?MYDEBUG("Settings is equal", []),
+             ok;
+         _ ->
+             true = ets:insert(ets_settings_table(State#state.vhost), Set),
+             (State#state.dbmod):set_user_settings(User, State#state.vhost, Set)
+    end,
+    {reply, ok, State};
+handle_call(Msg, _From, State) ->
+    ?INFO_MSG("Got call Msg: ~p, State: ~p", [Msg, State]),
+    {noreply, State}.
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% end ejabberd_web_admin callbacks
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+% ejabberd_hooks call
+handle_cast({addlog, Direction, Owner, Peer, Packet}, State) ->
+    case filter(Owner, Peer, State) of
+         true ->
+              case catch packet_parse(Owner, Peer, Packet, Direction, State) of
+                   ignore ->
+                     ok;
+                   {'EXIT', Reason} ->
+                     ?ERROR_MSG("Failed to parse: ~p", [Reason]);
+                   MsgT ->
+                     Dir_id = case Direction of
+                                   to -> "0";
+                                   from -> "1" 
+                              end,
+                     Msg = MsgT#msg{direction=Dir_id},
+                     (State#state.dbmod):log_message(State#state.vhost, Msg)
+              end;
+         false ->
+              ok
+    end,
+    {noreply, State};
+% ejabberdctl rebuild_stats/3
+handle_cast({rebuild_stats, VHost}, State) ->
+    % TODO: maybe spawn?
+    (State#state.dbmod):rebuild_stats(VHost),
+    {noreply, State};
+handle_cast({copy_messages, Backend}, State) ->
+    spawn(?MODULE, copy_messages, [[State, Backend]]),
+    {noreply, State};
+handle_cast({copy_messages, Backend, Date}, State) ->
+    spawn(?MODULE, copy_messages, [[State, Backend, Date]]),
+    {noreply, State};
+handle_cast(Msg, State) ->
+    ?INFO_MSG("Got cast Msg:~p, State:~p", [Msg, State]),
+    {noreply, State}.
+
+% actual starting of logging
+% from timer:send_after (in init)
+handle_info(start, State) ->
+    VHost = State#state.vhost,
+    DBMod = State#state.dbmod,
+
+    case DBMod:start(VHost, State#state.dbopts) of
+         {error, _Reason} ->
+           timer:sleep(10000),
+           {stop, db_connection_failed, State};
+         {ok, SPid} ->
+
+           ?INFO_MSG("~p connection established", [DBMod]),
+           
+           MonRef = erlang:monitor(process, SPid),
+           NewState=State#state{monref = MonRef},
+
+           ets:new(ets_settings_table(VHost), [named_table,public,set,{keypos, #user_settings.owner_name}]),
+           {ok, DoLog} = DBMod:get_users_settings(VHost),
+           ets:insert(ets_settings_table(VHost), DoLog),
+
+            % delete old records every 24 hours
+           case timer:send_interval(timer:hours(24), scheduled_purging) of
+                {ok, _Tref} ->
+                   ?MYDEBUG("Scheduled purging for ~p", [VHost]),
+                   ok;
+                {error, TReason} ->
+                   ?ERROR_MSG("Failed to schedule purging for ~p: ~p", [VHost, TReason])
+           end,
+
+           if
+             State#state.poll_users_settings > 0 ->
+               timer:send_interval(State#state.poll_users_settings * 1000, poll_users_settings);
+             % db polling disabled
+             State#state.poll_users_settings == 0 ->
+               ok;
+             true ->
+               timer:send_interval(10000, poll_users_settings)
+           end,
+
+           ejabberd_hooks:add(user_send_packet, VHost, ?MODULE, send_packet, 90),
+           ejabberd_hooks:add(user_receive_packet, VHost, ?MODULE, receive_packet, 90),
+           ?MYDEBUG("Added hooks for ~p", [VHost]),
+
+           ejabberd_ctl:register_commands(
+                           VHost,
+                           [{"rebuild_stats", "rebuild mod_logdb module stats for vhost"}],
+                           ?MODULE, rebuild_stats),
+           Supported_backends = lists:flatmap(fun({Backend, _Opts}) ->
+                                                  [atom_to_list(Backend), " "]
+                                              end, State#state.dbs),
+           ejabberd_ctl:register_commands(
+                           VHost,
+                           [{"copy_messages backend", "copy messages from backend to current backend. backends could be: " ++ Supported_backends }],
+                           ?MODULE, copy_messages_ctl),
+           ?MYDEBUG("Registered commands for ~p", [VHost]),
+
+          {noreply, NewState};
+        Rez ->
+          ?ERROR_MSG("Rez=~p", [Rez]),
+          timer:sleep(30000),
+          {stop, db_connection_failed, State}
+    end;
+% from timer:send_interval/2 (in start handle_info)
+handle_info(scheduled_purging, State) ->
+    scheduled_purging(State),
+    {noreply, State};
+% from timer:send_interval/2 (in start handle_info)
+handle_info(poll_users_settings, State) ->
+    VHost = State#state.vhost,
+    {ok, DoLog} = (State#state.dbmod):get_users_settings(VHost),
+    true = ets:delete_all_objects(ets_settings_table(VHost)),
+    ets:insert(ets_settings_table(VHost), DoLog),
+    {noreply, State};
+handle_info({'DOWN', _MonitorRef, process, _Pid, _Info}, State) ->
+    {stop, db_connection_dropped, State};
+handle_info({fetch_result, _, _}, State) ->
+    ?MYDEBUG("Got timed out mysql fetch result", []),
+    {noreply, State};
+handle_info(Info, State) ->
+    ?INFO_MSG("Got Info:~p, State:~p", [Info, State]),
+    {noreply, State}.
+
+terminate(db_connection_failed, _State) ->
+    ok;
+terminate(db_connection_dropped, State) ->
+    cleanup(State),
+    ok;
+terminate(Reason, #state{vhost=VHost, monref=MonRef} = State) ->
+    ?INFO_MSG("Reason: ~p", [Reason]),
+    erlang:demonitor(MonRef, [flush]),
+    (State#state.dbmod):stop(VHost),
+    cleanup(State),
+    ok.
+
+code_change(_OldVsn, State, _Extra) ->
+    {ok, State}.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% ejabberd_hooks callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+send_packet(Owner, Peer, P) ->
+    VHost = Owner#jid.lserver,
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:cast(Proc, {addlog, to, Owner, Peer, P}).
+
+receive_packet(_JID, Peer, Owner, P) -> 
+    VHost = Owner#jid.lserver,
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:cast(Proc, {addlog, from, Owner, Peer, P}).
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% ejabberdctl
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+rebuild_stats(_Val, VHost, ["rebuild_stats"]) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:cast(Proc, {rebuild_stats, VHost}),
+    {stop, ?STATUS_SUCCESS};
+rebuild_stats(Val, _VHost, _Args) ->
+    Val.
+
+copy_messages_ctl(_Val, VHost, ["copy_messages", Backend]) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:cast(Proc, {copy_messages, Backend}),
+    {stop, ?STATUS_SUCCESS};
+copy_messages_ctl(_Val, VHost, ["copy_messages", Backend, Date]) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:cast(Proc, {copy_messages, Backend, Date}),
+    {stop, ?STATUS_SUCCESS};
+copy_messages_ctl(Val, _VHost, _Args) ->
+    Val.
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% misc operations
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+% handle_cast({addlog, E}, _)
+% raw packet -> #msg
+packet_parse(Owner, Peer, Packet, Direction, State) ->
+    case xml:get_subtag(Packet, "body") of
+         false ->
+           ignore;
+         Body_xml ->
+           Message_type = xml:get_tag_attr_s("type", Packet),
+
+           case Message_type of
+                "groupchat" when State#state.groupchat == send, Direction == to ->
+                   ok;
+                "groupchat" when State#state.groupchat == send, Direction == from ->
+                   throw(ignore);
+                "groupchat" when State#state.groupchat == half ->
+                   Rooms = ets:match(muc_online_room, '$1'),
+                   Ni=lists:foldl(fun([{muc_online_room, {GName, GHost}, Pid}], Names) ->
+                                   case gen_fsm:sync_send_all_state_event(Pid, {get_jid_nick,Owner}) of
+                                        [] -> Names;
+                                        Nick -> 
+                                           lists:append(Names, [jlib:jid_to_string({GName, GHost, Nick})])
+                                   end
+                                  end, [], Rooms),
+                   case lists:member(jlib:jid_to_string(Peer), Ni) of
+                        true when Direction == from ->
+                          throw(ignore);
+                        _ ->
+                          ok
+                   end;
+                "groupchat" when State#state.groupchat == none ->
+                   throw(ignore);
+                _ ->
+                   ok
+           end,
+
+           Message_body = xml:get_tag_cdata(Body_xml),
+           Message_subject =
+              case xml:get_subtag(Packet, "subject") of
+                   false ->
+                     "";
+                   Subject_xml ->
+                     xml:get_tag_cdata(Subject_xml)
+              end,
+
+           OwnerName = stringprep:tolower(Owner#jid.user),
+           PName = stringprep:tolower(Peer#jid.user),
+           PServer = stringprep:tolower(Peer#jid.server),
+           PResource = Peer#jid.resource,
+
+           #msg{timestamp=get_timestamp(),
+                owner_name=OwnerName,
+                peer_name=PName,
+                peer_server=PServer,
+                peer_resource=PResource,
+                type=Message_type,
+                subject=Message_subject,
+                body=Message_body}
+    end.
+
+% called from handle_cast({addlog, _}, _) -> true (log messages) | false (do not log messages)
+filter(Owner, Peer, State) ->
+    OwnerS = Owner#jid.luser++"@"++Owner#jid.lserver,
+    PeerS = Peer#jid.luser++"@"++Peer#jid.lserver,
+    VHost = State#state.vhost,
+
+    LogTo = case ets:match_object(ets_settings_table(VHost),
+                                  #user_settings{owner_name=Owner#jid.luser, _='_'}) of
+                 [#user_settings{dolog_default=Default,
+                                 dolog_list=DLL,
+                                 donotlog_list=DNLL}] ->
+                      A = lists:member(PeerS, DLL),
+                      B = lists:member(PeerS, DNLL),
+                      if
+                        A -> true;
+                        B -> false;
+                        Default == true -> true;
+                        Default == false -> false;
+                        true -> State#state.default_to_log
+                      end;
+                 _ -> State#state.default_to_log
+            end,
+
+    lists:all(fun(O) -> O end, 
+              [not lists:member(OwnerS, State#state.ignore_jids),
+               not lists:member(PeerS, State#state.ignore_jids),
+               LogTo]).
+    
+%    {Orientation, From, To, Packet} = E,
+%    {xmlelement, Stanza_str, _Attrs, _Els} = Packet,
+%    Stanza = list_to_atom(Stanza_str),
+
+%    {Host_local, Host_remote} =
+%       case Orientation of
+%            send -> {From#jid.lserver, To#jid.lserver};
+%            recv -> {To#jid.lserver, From#jid.lserver}
+%       end,
+%    Direction = 
+%       case Host_remote of
+%            Host_local -> 
+%                internal;
+%            _ ->
+%                case lists:member(Host_remote, ?MYHOSTS) of
+%                     true -> vhosts;
+%                     false -> external
+%                end
+%       end,
+%    Body = case Message#msg.body of
+%                false -> false;
+%                _ -> true
+%           end,
+
+%    ToBool = case Message#msg.to_user of
+%                  [] -> false;
+%                  _ -> true
+%             end,
+
+%    OrientationO =
+%       case Message#msg.type of
+%            "groupchat" ->
+%                case State#state.groupchat of
+%                     send -> [send];
+%                     all -> [send, recv];
+%                     none -> [];
+%                     _ -> []
+%                end;
+%            _ -> 
+%                case Direction of
+%                     external -> [send, recv];
+%                     vhosts -> [send, recv];
+%                     internal -> [send]
+%                end
+%       end,
+
+
+    %?MYDEBUG("LogTo=~p for ~p at ~p", [LogTo, LUser, VHost]),
+    %LogTo.
+
+    %LogFrom = case ets:match(ets_settings_table(VHost), {Message#msg.from_user, '$1'}) of 
+    %             [[true]] when Message#msg.from_server==VHost -> true;
+    %             [[false]] when Message#msg.from_server==VHost -> false;
+    %             _ -> State#state.default_to_log
+    %          end,
+
+%    lists:all(fun(O) -> O end, 
+%              [lists:member(Orientation, OrientationO),
+%               lists:member(Stanza, [iq, message, presence, other]),
+%               lists:member(Direction, [internal, vhosts, external]),
+%               LogTo,
+%               LogFrom,
+%               Body,
+%               ToBool]).
+
+% called from handle_info(scheduled_purging, _) 
+scheduled_purging(#state{purge_older_days=PDays, vhost=VHost} = _State) ->
+    ?MYDEBUG("Starting scheduled purging of old records for ~p", [VHost]),
+    case PDays of
+         never ->
+            ok;
+         Days when is_integer(Days) ->
+            purge_old_records_at(VHost, integer_to_list(Days));
+         _ ->
+            ok
+    end.
+
+purge_old_records_at(VHost, Days) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+
+    Dates = gen_server:call(Proc, {get_dates, {VHost}}),
+    DateNow = calendar:datetime_to_gregorian_seconds({date(), {0,0,1}}),
+    DateDiff = list_to_integer(Days)*24*60*60,
+    ?MYDEBUG("Purging tables older than ~s days", [Days]),
+    lists:foreach(fun(Date) ->
+                    {ok, [Year, Month, Day]} = regexp:split(Date, "[^0-9]+"),
+                    DateInSec = calendar:datetime_to_gregorian_seconds({{list_to_integer(Year), list_to_integer(Month), list_to_integer(Day)}, {0,0,1}}),
+                    if
+                     (DateNow - DateInSec) > DateDiff ->
+                        gen_server:call(Proc, {delete_messages_table_at, {VHost, Date}});
+                     true -> 
+                        ?MYDEBUG("Skipping messages at ~p", [Date])
+                    end
+              end, Dates).
+
+% called from get_vhost_stats/2, get_user_stats/3
+sort_stats(Stats) ->
+    % Stats = [{"2003-4-15",1}, {"2006-8-18",1}, ... ]
+    CFun = fun({TableName, Count}) ->
+                 {ok, [Year, Month, Day]} = regexp:split(TableName, "[^0-9]+"),
+                 { calendar:datetime_to_gregorian_seconds({{list_to_integer(Year), list_to_integer(Month), list_to_integer(Day)}, {0,0,1}}), Count }
+           end,
+    % convert to [{63364377601,1}, {63360662401,1}, ... ]
+    CStats = lists:map(CFun, Stats),
+    % sort by date
+    SortedStats = lists:reverse(lists:keysort(1, CStats)),
+    % convert to [{"2007-12-9",1}, {"2007-10-27",1}, ... ] sorted list
+    [{mod_logdb:convert_timestamp_brief(TableSec), Count} || {TableSec, Count} <- SortedStats].
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% Date/Time operations
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% return float seconds elapsed from "zero hour" as list
+get_timestamp() ->
+    {MegaSec, Sec, MicroSec} = now(),
+    [List] = io_lib:format("~.5f", [MegaSec*1000000 + Sec + MicroSec/1000000]),
+    List.
+
+% convert float seconds elapsed from "zero hour" to local time "%Y-%m-%d %H:%M:%S" string
+convert_timestamp(Seconds) when is_list(Seconds) ->
+    convert_timestamp(list_to_float(Seconds));
+convert_timestamp(Seconds) when is_float(Seconds) ->
+    GregSec = trunc(Seconds + 719528*86400),
+    UnivDT = calendar:gregorian_seconds_to_datetime(GregSec),
+    {{Year, Month, Day},{Hour, Minute, Sec}} = calendar:universal_time_to_local_time(UnivDT),
+    integer_to_list(Year) ++ "-" ++ integer_to_list(Month) ++ "-" ++ integer_to_list(Day) ++ " " ++ integer_to_list(Hour) ++ ":" ++ integer_to_list(Minute) ++ ":" ++ integer_to_list(Sec);
+% convert integer gregorian seconds to "%Y-%m-%d %H:%M:%S" string
+convert_timestamp(Seconds) when is_integer(Seconds) ->
+    {{Year, Month, Day},{Hour, Minute, Sec}} = calendar:gregorian_seconds_to_datetime(Seconds),
+    integer_to_list(Year) ++ "-" ++ integer_to_list(Month) ++ "-" ++ integer_to_list(Day) ++ " " ++ integer_to_list(Hour) ++ ":" ++ integer_to_list(Minute) ++ ":" ++ integer_to_list(Sec).
+
+% convert float seconds elapsed from "zero hour" to local time "%Y-%m-%d" string
+convert_timestamp_brief(Seconds) when is_float(Seconds) ->
+    GregSec = trunc(Seconds + 719528*86400),
+    UnivDT = calendar:gregorian_seconds_to_datetime(GregSec),
+    {{Year, Month, Day},{_Hour, _Minute, _Sec}} = calendar:universal_time_to_local_time(UnivDT),
+    integer_to_list(Year) ++ "-" ++ integer_to_list(Month) ++ "-" ++ integer_to_list(Day);
+% convert integer gregorian seconds to "%Y-%m-%d" string
+convert_timestamp_brief(Seconds) when is_integer(Seconds) ->
+    {{Year, Month, Day},{_Hour, _Minute, _Sec}} = calendar:gregorian_seconds_to_datetime(Seconds),
+    integer_to_list(Year) ++ "-" ++ integer_to_list(Month) ++ "-" ++ integer_to_list(Day);
+convert_timestamp_brief(Seconds) when is_list(Seconds) ->
+    convert_timestamp_brief(list_to_float(Seconds)).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% DB operations (get)
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+get_vhost_stats(VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_vhost_stats, {VHost}}, ?CALL_TIMEOUT).
+
+get_vhost_stats_at(VHost, Date) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_vhost_stats_at, {VHost, Date}}, ?CALL_TIMEOUT).
+
+get_user_stats(User, VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_user_stats, {User, VHost}}, ?CALL_TIMEOUT).
+
+get_user_messages_at(User, VHost, Date) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_user_messages_at, {User, VHost, Date}}, ?CALL_TIMEOUT).
+
+get_dates(VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_dates, {VHost}}, ?CALL_TIMEOUT).
+
+get_user_settings(User, VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_user_settings, {User}}, ?CALL_TIMEOUT).
+
+set_user_settings(User, VHost, Set) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {set_user_settings, {User, Set}}).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% Web admin callbacks (delete)
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+user_messages_at_parse_query(VHost, Date, Msgs, Query) ->
+    case lists:keysearch("delete", 1, Query) of
+         {value, _} ->
+             PMsgs = lists:filter(
+                              fun(Msg) ->
+                                   ID = jlib:encode_base64(binary_to_list(term_to_binary(Msg#msg.timestamp))),
+                                   lists:member({"selected", ID}, Query)
+                              end, Msgs),
+             Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+             ok = gen_server:call(Proc,
+                                  {delete_messages_by_user_at,
+                                   {VHost, PMsgs, Date}}),
+             nothing;
+         false ->
+             nothing
+    end.
+
+user_messages_parse_query(User, VHost, Query) ->
+    Dates = get_dates(VHost),
+    case lists:keysearch("delete", 1, Query) of
+         {value, _} ->
+             PDates = lists:filter(
+                              fun(Date) ->
+                                   ID = jlib:encode_base64(binary_to_list(term_to_binary(User++Date))),
+                                   lists:member({"selected", ID}, Query)
+                              end, Dates),
+             Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+             Rez = lists:foldl(
+                          fun(Date, Acc) ->
+                              lists:append(Acc,
+                                           [gen_server:call(Proc,
+                                                            {delete_all_messages_by_user_at,
+                                                             {User, VHost, Date}})])
+                          end, [], PDates),
+             case lists:member(error, Rez) of
+                  true ->
+                    error;
+                  false ->
+                    ok
+             end;
+         false ->
+             nothing
+    end.
+
+vhost_messages_parse_query(VHost, Query) ->
+    Dates = get_dates(VHost),
+    case lists:keysearch("delete", 1, Query) of
+         {value, _} ->
+             PDates = lists:filter(
+                              fun(Date) ->
+                                   ID = jlib:encode_base64(binary_to_list(term_to_binary(VHost++Date))),
+                                   lists:member({"selected", ID}, Query)
+                              end, Dates),
+             Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+             Rez = lists:foldl(fun(Date, Acc) ->
+                                   lists:append(Acc, [gen_server:call(Proc,
+                                                                      {delete_messages_table_at,
+                                                                       {VHost, Date}})])
+                               end, [], PDates),
+             case lists:member(error, Rez) of
+                  true ->
+                    error;
+                  false ->
+                    nothing
+             end;
+         false ->
+             nothing
+    end.
+
+vhost_messages_at_parse_query(VHost, Date, Stats, Query) ->
+    case lists:keysearch("delete", 1, Query) of
+         {value, _} ->
+             PStats = lists:filter(
+                              fun({User, _Count}) ->
+                                   ID = jlib:encode_base64(binary_to_list(term_to_binary(User++VHost))),
+                                   lists:member({"selected", ID}, Query)
+                              end, Stats),
+             Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+             Rez = lists:foldl(fun({User, _Count}, Acc) ->
+                                   lists:append(Acc, [gen_server:call(Proc,
+                                                                      {delete_all_messages_by_user_at,
+                                                                       {User, VHost, Date}})])
+                               end, [], PStats),
+             case lists:member(error, Rez) of
+                  true ->
+                    error;
+                  false ->
+                    ok
+             end;
+         false ->
+             nothing
+    end.
+
+copy_messages([State, From]) ->
+    VHost = State#state.vhost,
+    ?INFO_MSG("Going to copy messages from ~p for ~p", [From, VHost]),
+
+    {value, {FromDBName, FromDBOpts}} = lists:keysearch(list_to_atom(From), 1, State#state.dbs),
+
+    FromDBMod = list_to_atom(atom_to_list(?MODULE) ++ "_" ++ atom_to_list(FromDBName)),
+
+    {ok, _FromPid} = FromDBMod:start(VHost, FromDBOpts),
+ 
+    Dates = FromDBMod:get_dates(VHost),
+    DatesLength = length(Dates),
+
+    lists:foldl(fun(Date, Acc) ->
+                   case copy_messages_int([FromDBMod, State#state.dbmod, VHost, Date]) of
+                        ok ->
+                          ?INFO_MSG("Copied messages at ~p (~p/~p)", [Date, Acc, DatesLength]);
+                        Value ->
+                          ?ERROR_MSG("Failed to copy messages at ~p (~p/~p): ~p", [Date, Acc, DatesLength, Value])
+                   end,
+                   Acc + 1
+                  end, 1, Dates),
+    ?INFO_MSG("Copied messages from ~p",  [From]);
+copy_messages([State, From, Date]) ->
+    VHost = State#state.vhost,
+
+    {value, {FromDBName, FromDBOpts}} = lists:keysearch(list_to_atom(From), 1, State#state.dbs),
+    FromDBMod = list_to_atom(atom_to_list(?MODULE) ++ "_" ++ atom_to_list(FromDBName)),
+    {ok, _FromPid} = FromDBMod:start(VHost, FromDBOpts),
+    case catch copy_messages_int([FromDBMod, State#state.dbmod, VHost, Date]) of
+         {'exit', Reason} ->
+           ?ERROR_MSG("Failed to copy messages at ~p: ~p", [Date, Reason]);
+         ok ->
+           ?INFO_MSG("Copied messages at ~p", [Date]);
+         Value ->
+           ?ERROR_MSG("Failed to copy messages at ~p: ~p", [Date, Value])
+    end.
+
+copy_messages_int([FromDBMod, ToDBMod, VHost, Date]) ->
+    ets:new(mod_logdb_temp, [named_table, set, public]),
+    {Time, Value} = timer:tc(?MODULE, copy_messages_int_tc, [[FromDBMod, ToDBMod, VHost, Date]]),
+    ets:delete_all_objects(mod_logdb_temp),
+    ets:delete(mod_logdb_temp),
+    ?INFO_MSG("copy_messages at ~p elapsed ~p sec", [Date, Time/1000000]),
+    Value.
+
+copy_messages_int_tc([FromDBMod, ToDBMod, VHost, Date]) ->
+    ?INFO_MSG("Going to copy messages from ~p for ~p at ~p", [FromDBMod, VHost, Date]),
+   
+    ok = FromDBMod:rebuild_stats_at(VHost, Date),
+    catch mod_logdb:rebuild_stats_at(VHost, Date),
+    {ok, FromStats} = FromDBMod:get_vhost_stats_at(VHost, Date),
+    ToStats = case mod_logdb:get_vhost_stats_at(VHost, Date) of
+                   {ok, Stats} -> Stats;
+                   {error, _} -> []
+              end,
+
+    FromStatsS = lists:keysort(1, FromStats),
+    ToStatsS = lists:keysort(1, ToStats),
+
+    StatsLength = length(FromStats),
+
+    if 
+       FromStats == [] ->
+          ?INFO_MSG("No messages were found at ~p", [Date]);
+       true ->
+          if
+            FromStatsS == ToStatsS ->
+              ?INFO_MSG("Stats are equal at ~p", [Date]);
+            % TODO:
+            ToStats /= [] ->
+              ?INFO_MSG("Destination table not empty at ~p", [Date]);
+            true ->
+              CopyFun =
+                if
+                 FromDBMod /= mod_logdb_mnesia_old ->
+                     fun({User, _Count}, Acc) ->
+                              {ok, Msgs} = FromDBMod:get_user_messages_at(User, VHost, Date),
+
+                              MAcc =
+                                lists:foldl(fun(Msg, MFAcc) ->
+                                                ok = ToDBMod:log_message(VHost, Msg),
+                                                MFAcc + 1
+                                            end, 0, Msgs),
+                              NewAcc = Acc + 1,
+                              ?INFO_MSG("Copied ~p messages for ~p (~p/~p) at ~p", [MAcc, User, NewAcc, StatsLength, Date]),
+                              %timer:sleep(100),
+                              NewAcc
+                          end;
+                 true ->
+                     fun({User, _Count}, Acc) ->
+                              {ok, Msgs} = FromDBMod:get_user_messages_at(User, VHost, Date),
+
+                              MAcc =
+                                lists:foldl(
+                                  fun({msg, TU, TS, TR, FU, FS, FR, Type, Subj, Body, Timest},
+                                      MFAcc) ->
+                                        [Timestamp] = io_lib:format("~.5f", [Timest]),
+                                        case ets:member(mod_logdb_temp, Timestamp) of
+                                            false ->
+                                               if
+                                                % from
+                                                TS == VHost ->
+                                                  TMsg = #msg{timestamp=Timestamp,
+                                                              owner_name=TU,
+                                                              peer_name=FU, peer_server=FS, peer_resource=FR,
+                                                              direction="1",
+                                                              type=Type,
+                                                              subject=Subj, body=Body},
+                                                  ok = ToDBMod:log_message(VHost, TMsg);
+                                                true -> ok
+                                              end,
+                                              if
+                                                % to
+                                                FS == VHost ->
+                                                  FMsg = #msg{timestamp=Timestamp,
+                                                              owner_name=FU,
+                                                              peer_name=TU, peer_server=TS, peer_resource=TR,
+                                                              direction="0",
+                                                              type=Type,
+                                                              subject=Subj, body=Body},
+                                                  ok = ToDBMod:log_message(VHost, FMsg);
+                                                true -> ok
+                                              end,
+                                              ets:insert(mod_logdb_temp, {Timestamp}),
+                                              MFAcc + 1;
+                                            true -> % not ets:member
+                                               MFAcc
+                                        end % case
+                                       end, 0, Msgs), % foldl
+                              NewAcc = Acc + 1,
+                              ?INFO_MSG("Copied ~p messages for ~p (~p/~p) at ~p", [MAcc, User, NewAcc, StatsLength, Date]),
+                              %timer:sleep(100),
+                              NewAcc
+                     end % fun
+                end, % if
+              lists:foldl(CopyFun, 0, FromStats),
+              ok = ToDBMod:rebuild_stats_at(VHost, Date)
+              %timer:sleep(1000)
+          end
+    end,
+    ok.
+
+list_to_bool(Num) ->
+    case lists:member(Num, ["t", "true", "y", "yes", "1"]) of
+         true ->
+           true;
+         false ->
+           case lists:member(Num, ["f", "false", "n", "no", "0"]) of
+                true ->
+                  false;
+                false ->
+                  error
+           end
+    end.
+
+bool_to_list(true) ->
+    "TRUE";
+bool_to_list(false) ->
+    "FALSE".
--- mod_logdb.hrl.orig	Wed Jun 13 10:26:33 2007
+++ mod_logdb.hrl	Tue Jun 12 16:06:45 2007
@@ -0,0 +1,23 @@
+%-define(logdb_debug, true).
+
+-ifdef(logdb_debug).
+-define(MYDEBUG(Format, Args), io:format("D(~p:~p:~p) : "++Format++"~n",
+                                       [calendar:local_time(),?MODULE,?LINE]++Args)).
+-else.
+-define(MYDEBUG(_F,_A),[]).
+-endif.
+
+-record(msg,   {timestamp,
+                owner_name,
+                peer_name, peer_server, peer_resource,
+                direction,
+                type, subject,
+                body}).
+
+-record(user_settings, {owner_name,
+                        dolog_default,
+                        dolog_list=[],
+                        donotlog_list=[]}).
+
+% gen_server call timeout
+-define(CALL_TIMEOUT, 60000).
--- mod_logdb_mysql.erl.orig	Wed Jun 13 10:26:33 2007
+++ mod_logdb_mysql.erl	Mon Jun 11 21:43:26 2007
@@ -0,0 +1,825 @@
+-module(mod_logdb_mysql).
+
+-include("mod_logdb.hrl").
+-include("ejabberd.hrl").
+-include("jlib.hrl").
+
+-behaviour(gen_logdb).
+-behaviour(gen_server).
+
+% gen_server
+-export([code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2]).
+
+-export([start/2, stop/1,
+         log_message/2,
+         rebuild_stats/1,
+         rebuild_stats_at/2,
+         delete_messages_by_user_at/3, delete_all_messages_by_user_at/3, delete_messages_table_at/2,
+         get_vhost_stats/1, get_vhost_stats_at/2, get_user_stats/2, get_user_messages_at/3,
+         get_dates/1,
+%         get_users_settings/2, get_user_settings/3, set_user_settings/4]).
+         get_users_settings/1, set_user_settings/3]).
+
+-define(TIMEOUT, 60000).
+-define(INDEX_SIZE, integer_to_list(170)).
+-define(PROCNAME, mod_logdb_mysql).
+
+-record(state, {dbref}).
+
+% replace "." with "_"
+escape_vhost(VHost) -> lists:map(fun(46) -> 95;
+                                    (A) -> A
+                                 end, VHost).
+
+tables_prefix(VHost) -> "messages_" ++ escape_vhost(VHost) ++ "_".
+
+table_name(VHost, Date) -> "`" ++ tables_prefix(VHost) ++ Date ++ "`".
+
+% stats_table should not start with tables_prefix(VHost) ! 
+stats_table(VHost) -> "`messages-stats_" ++ escape_vhost(VHost) ++ "`".
+settings_table(VHost) -> "`logdb_settings_" ++ escape_vhost(VHost) ++ "`".
+
+ets_users_table(VHost) -> list_to_atom("logdb_users_" ++ VHost).
+ets_servers_table(VHost) -> list_to_atom("logdb_servers_" ++ VHost).
+ets_types_table(VHost) -> list_to_atom("logdb_types_" ++ VHost).
+
+users_table(VHost) -> "`" ++ "logdb_users_" ++ escape_vhost(VHost) ++ "`".
+servers_table(VHost) -> "`" ++ "logdb_servers_" ++ escape_vhost(VHost) ++ "`".
+types_table(VHost) -> "`" ++ "logdb_types_" ++ escape_vhost(VHost) ++ "`".
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_logdb callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+start(VHost, Opts) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:start({local, Proc}, ?MODULE, [VHost, Opts], []).
+
+init([VHost, Opts]) ->
+   crypto:start(),
+
+   Server = gen_mod:get_opt(server, Opts, "localhost"),
+   Port = gen_mod:get_opt(port, Opts, 3128),
+   DB = gen_mod:get_opt(db, Opts, "ejabberd_logdb"),
+   User = gen_mod:get_opt(user, Opts, "root"),
+   Password = gen_mod:get_opt(password, Opts, ""),
+
+   NoLogFun = fun(_Level, _Format, _Argument) -> ok end,
+   case mysql_conn:start(Server, Port, User, Password, DB, NoLogFun) of
+       {ok, DBRef} ->
+           ok = create_stats_table(DBRef, VHost),
+           ok = create_settings_table(DBRef, VHost),
+           ok = create_users_table(DBRef, VHost),
+           ok = create_servers_table(DBRef, VHost),
+           ok = create_type_table(DBRef, VHost),
+           erlang:monitor(process, DBRef),
+           {ok, #state{dbref=DBRef}};
+       {error, Reason} ->
+           ?ERROR_MSG("MySQL connection failed: ~p~n", [Reason]),
+           {stop, mysql_connection_failed}
+   end.
+
+handle_call({get_users_settings, VHost}, _From, State) ->
+    DBRef = State#state.dbref,
+    Query = ["SELECT username,dolog_default,dolog_list,donotlog_list ",
+                "FROM ",settings_table(VHost)," ",
+             "JOIN ",users_table(VHost)," ON user_id=owner_id;"],
+    Reply = 
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              {ok, [#user_settings{owner_name=Owner,
+                             dolog_default=mod_logdb:list_to_bool(DoLogDef),
+                             dolog_list=binary_to_term(iolist_to_binary(DoLogL)),
+                             donotlog_list=binary_to_term(iolist_to_binary(DoNotLogL))
+                            } || [Owner, DoLogDef, DoLogL, DoNotLogL] <- Result]};
+           {error, Reason} ->
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({log_message, VHost, Msg}, _From, State) ->
+    {reply, log_message_int(State#state.dbref, VHost, Msg), State};
+handle_call({delete_messages_by_user_at, VHost, Msgs, Date}, _From, State) ->
+    DBRef = State#state.dbref,
+    Temp = lists:flatmap(fun(#msg{timestamp=Timestamp} = _Msg) ->
+                             ["\"",Timestamp,"\"",","]
+                         end, Msgs),
+
+    Temp1 = lists:append([lists:sublist(Temp, length(Temp)-1), ");"]),
+
+    Query = ["DELETE FROM ",table_name(VHost, Date)," ",
+                             "WHERE timestamp IN (", Temp1],
+
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {updated, Aff} ->
+              ?MYDEBUG("Aff=~p", [Aff]),
+              rebuild_stats_at_int(DBRef, VHost, Date);
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({delete_all_messages_by_user_at, User, VHost, Date}, _From, State) ->
+    DBRef = State#state.dbref,
+    Owner_id = get_user_id(DBRef, VHost, User),
+    DQuery = ["DELETE FROM ",table_name(VHost, Date)," ",
+                 "WHERE owner_id=\"",Owner_id,"\";"],
+    Reply =
+      case sql_query_internal(DBRef, DQuery) of
+           {updated, _} ->
+              rebuild_stats_at_int(DBRef, VHost, Date);
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({delete_messages_table_at, VHost, Date}, _From, State) ->
+    DBRef = State#state.dbref,
+    Reply =
+      case sql_query_internal(DBRef, ["DROP TABLE ",table_name(VHost, Date),";"]) of
+           {updated, _} ->
+              Query = ["DELETE FROM ",stats_table(VHost)," "
+                          "WHERE at=\"",Date,"\";"],
+              case sql_query_internal(DBRef, Query) of
+                   {updated, _} ->
+                      ok;
+                   {error, _} ->
+                      error
+              end;
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({get_vhost_stats, VHost}, _From, State) ->
+    DBRef = State#state.dbref,
+    SName = stats_table(VHost),
+    Query = ["SELECT at, sum(count) ",
+                "FROM ",SName," ",
+                "GROUP BY at;"
+            ],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              Fun = fun([Date, Count]) ->
+                          {Date, list_to_integer(Count)}
+                    end,
+              Stats = mod_logdb:sort_stats(lists:map(Fun, Result)),
+              {ok, Stats};
+           {error, Reason} ->
+              % TODO: Duplicate error message ?
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_vhost_stats_at, VHost, Date}, _From, State) ->
+    DBRef = State#state.dbref,
+    SName = stats_table(VHost),
+    Query = ["SELECT username, count ",
+                "FROM ",SName," ",
+                "JOIN ",users_table(VHost)," ON owner_id=user_id "
+                "WHERE at=\"",Date,"\";"
+            ],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              {ok, lists:reverse(
+                     lists:keysort(2,
+                                   [ {User, list_to_integer(Count)} || [User, Count] <- Result]))};
+           {error, Reason} ->
+              % TODO:
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_user_stats, User, VHost}, _From, State) ->
+    DBRef = State#state.dbref,
+    SName = stats_table(VHost),
+    Query = ["SELECT at, count ",
+                "FROM ",SName," ",
+                "WHERE owner_id=\"",get_user_id(DBRef, VHost, User),"\";"
+            ],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              Fun = fun([Date, Count]) ->
+                          {Date, list_to_integer(Count)}
+                    end,
+              {ok, mod_logdb:sort_stats(lists:map(Fun, Result))};
+           {error, Result} ->
+              {error, Result}
+      end,
+    {reply, Reply, State};
+handle_call({get_user_messages_at, User, VHost, Date}, _From, State) ->
+    DBRef = State#state.dbref,
+    TName = table_name(VHost, Date),
+    UName = users_table(VHost),
+    SName = servers_table(VHost),
+    TyName = types_table(VHost),
+    Query = ["SELECT users.username,",
+                    "servers.server,",
+                    "messages.peer_resource,",
+                    "messages.direction,"
+                    "types.type,"
+                    "messages.subject,"
+                    "messages.body,"
+                    "messages.timestamp "
+               "FROM ",TName," AS messages "
+                "JOIN ",UName," AS users ON peer_name_id=user_id ",
+                "JOIN ",SName," AS servers ON peer_server_id=server_id ",
+                "JOIN ",TyName," AS types ON types.type_id=messages.type_id ",
+               "WHERE owner_id=\"",get_user_id(DBRef, VHost, User),"\" ",
+               "ORDER BY timestamp ASC;"],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              Fun = fun([Peer_name, Peer_server, Peer_resource,
+                         "0",
+                         Type,
+                         Subject, Body,
+                         Timestamp]) ->
+                          #msg{peer_name=Peer_name, peer_server=Peer_server, peer_resource=Peer_resource,
+                               direction=to,
+                               type=Type,
+                               subject=Subject, body=Body,
+                               timestamp=Timestamp};
+                       ([Peer_name, Peer_server, Peer_resource,
+                         "1",
+                         Type,
+                         Subject, Body,
+                         Timestamp]) ->
+                          #msg{peer_name=Peer_name, peer_server=Peer_server, peer_resource=Peer_resource,
+                               direction=from,
+                               type=Type,
+                               subject=Subject, body=Body,
+                               timestamp=Timestamp}
+                    end,
+              {ok, lists:map(Fun, Result)};
+           {error, Reason} ->
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_dates, VHost}, _From, State) ->
+    {reply, get_dates_int(State#state.dbref, VHost), State};
+handle_call({set_user_settings, User, VHost, #user_settings{dolog_default=DoLogDef,
+                                                     dolog_list=DoLogL,
+                                                     donotlog_list=DoNotLogL}},
+            _From, State) ->
+    DBRef = State#state.dbref,
+    DoLogLB = binary_to_list(term_to_binary(DoLogL)),
+    DoNotLogLB = binary_to_list(term_to_binary(DoNotLogL)),
+
+    User_id = get_user_id(DBRef, VHost, User),
+
+    Query = ["UPDATE ",settings_table(VHost)," ",
+                "SET dolog_default=",mod_logdb:bool_to_list(DoLogDef),", ",
+                    "dolog_list='",DoLogLB,"', ",
+                    "donotlog_list='",DoNotLogLB,"' ",
+                "WHERE owner_id=\"",User_id,"\";"],
+
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {updated, 0} ->
+              IQuery = ["INSERT INTO ",settings_table(VHost)," ",
+                            "(owner_id, dolog_default, dolog_list, donotlog_list) ",
+                            "VALUES ",
+                            "('",User_id,"', '",mod_logdb:bool_to_list(DoLogDef),"','",DoLogLB,"','",DoNotLogLB,"');"],
+              case sql_query_internal_silent(DBRef, IQuery) of
+                   {updated, _} ->
+                       ?MYDEBUG("New settings for ~s@~s", [User, VHost]),
+                       ok;
+                   {error, Reason} ->
+                       case regexp:match(Reason, "#23000") of
+                            % Already exists
+                            {match, _, _} ->
+                                ok;
+                             _ ->
+                                ?ERROR_MSG("Failed setup user ~p@~p: ~p", [User, VHost, Reason]),
+                                error
+                       end
+              end;
+           {updated, 1} ->
+              ?MYDEBUG("Updated settings for ~s@~s", [User, VHost]),
+              ok;
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({rebuild_stats, VHost}, _From, State) ->
+    DBRef = State#state.dbref,
+    ok = delete_nonexistent_stats(DBRef, VHost),
+    Reply = 
+      lists:foreach(fun(Date) ->
+                        catch rebuild_stats_at_int(DBRef, VHost, Date)
+                    end, get_dates_int(DBRef, VHost)),
+    {reply, Reply, State};
+handle_call({rebuild_stats_at, VHost, Date}, _From, State) ->
+    DBRef = State#state.dbref,
+    Reply = rebuild_stats_at_int(DBRef, VHost, Date),
+    {reply, Reply, State};
+handle_call({stop, VHost}, _From, State) ->
+   ets:delete(ets_users_table(VHost)),
+   ets:delete(ets_servers_table(VHost)),
+   ?MYDEBUG("Stoping mysql backend", []),
+   {stop, normal, ok, State};
+handle_call(Msg, _From, State) ->
+    ?INFO_MSG("Got call Msg: ~p, State: ~p", [Msg, State]),
+    {noreply, State}.
+handle_cast(Msg, State) ->
+    ?INFO_MSG("Got cast Msg:~p, State:~p", [Msg, State]),
+    {noreply, State}.
+handle_info({'DOWN', _MonitorRef, process, _Pid, _Info}, State) ->
+    {stop, connection_dropped, State};
+handle_info(Info, State) ->
+    ?INFO_MSG("Got Info:~p, State:~p", [Info, State]),
+    {noreply, State}.
+
+terminate(_Reason, _State) ->
+    ok.
+
+code_change(_OldVsn, State, _Extra) ->
+    {ok, State}.
+
+get_users_settings(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_users_settings, VHost}, ?CALL_TIMEOUT).
+log_message(VHost, Msg) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {log_message, VHost, Msg}, ?CALL_TIMEOUT).
+delete_messages_by_user_at(VHost, Msgs, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_messages_by_user_at, VHost, Msgs, Date}, ?CALL_TIMEOUT).
+delete_all_messages_by_user_at(User, VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_all_messages_by_user_at, User, VHost, Date}, ?CALL_TIMEOUT).
+delete_messages_table_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_messages_table_at, VHost, Date}, ?CALL_TIMEOUT).
+get_vhost_stats(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_vhost_stats, VHost}, ?CALL_TIMEOUT).
+get_vhost_stats_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_vhost_stats_at, VHost, Date}, ?CALL_TIMEOUT).
+get_user_stats(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_stats, User, VHost}, ?CALL_TIMEOUT).
+get_user_messages_at(User, VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_messages_at, User, VHost, Date}, ?CALL_TIMEOUT).
+get_dates(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_dates, VHost}, ?CALL_TIMEOUT).
+set_user_settings(User, VHost, Set) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {set_user_settings, User, VHost, Set}, ?CALL_TIMEOUT).
+rebuild_stats(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {rebuild_stats, VHost}, ?CALL_TIMEOUT).
+rebuild_stats_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {rebuild_stats_at, VHost, Date}, ?CALL_TIMEOUT).
+stop(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {stop, VHost}, ?CALL_TIMEOUT).
+
+log_message_int(DBRef, VHost, #msg{timestamp=Timestamp}=Msg) ->
+   Date = mod_logdb:convert_timestamp_brief(Timestamp),
+
+   Table = table_name(VHost, Date),
+   Owner_id = get_user_id(DBRef, VHost, Msg#msg.owner_name),
+   Peer_name_id = get_user_id(DBRef, VHost, Msg#msg.peer_name),
+   Peer_server_id = get_server_id(DBRef, VHost, Msg#msg.peer_server),
+   Type_id = get_type_id(DBRef, VHost, Msg#msg.type),
+
+   Query = ["INSERT INTO ",Table," ",
+                "(owner_id,",
+                 "peer_name_id,",
+                 "peer_server_id,",
+                 "peer_resource,",
+                 "direction,",
+                 "type_id,",
+                 "subject,",
+                 "body,",
+                 "timestamp) ",
+                "VALUES ",
+                "('", Owner_id, "',",
+                  "'", Peer_name_id, "',",
+                  "'", Peer_server_id, "',",
+                  "'", ejabberd_odbc:escape(Msg#msg.peer_resource), "',",
+                  "'", Msg#msg.direction, "',",
+                  "'", Type_id, "',",
+                  "'", ejabberd_odbc:escape(Msg#msg.subject), "',",
+                  "'", ejabberd_odbc:escape(Msg#msg.body), "',",
+                  "'", Msg#msg.timestamp, "');"],
+
+    case sql_query_internal_silent(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Logged ok for ~p, peer: ~p", [Msg#msg.owner_name++"@"++VHost,
+                                                    Msg#msg.peer_name++"@"++Msg#msg.peer_server]),
+            ok = increment_user_stats(DBRef, Owner_id, VHost, Date);
+         {error, Reason} ->
+            case regexp:match(Reason, "#42S02") of
+                 % Table doesn't exist
+                 {match, _, _} ->
+                   case create_msg_table(DBRef, VHost, Date) of
+                        error ->
+                          error;
+                        ok ->
+                          log_message_int(DBRef, VHost, Msg)
+                   end;
+                 _ ->
+                   ?ERROR_MSG("Failed to log message: ~p", [Reason]),
+                   error
+            end
+    end.
+
+get_dates_int(DBRef, VHost) ->
+    case sql_query_internal(DBRef, ["SHOW TABLES"]) of
+         {data, Tables} ->
+            MessagesTables =
+                  lists:filter(fun([Table]) ->
+                                   lists:prefix(tables_prefix(VHost), Table)
+                               end,
+                               Tables),
+
+            lists:map(fun([Table]) ->
+                           lists:sublist(Table,
+                                         length(tables_prefix(VHost))+1,
+                                         length(Table))
+                      end, MessagesTables);
+         {error, _} ->
+            []
+    end.
+
+get_user_name(DBRef, VHost, User_id) ->
+  case ets:match(ets_users_table(VHost), {'$1', User_id}) of
+       [[User]] -> User;
+       % this can be in clustered environment
+       [] ->
+         update_users_from_db(DBRef, VHost),
+         [[User1]] = ets:match(ets_users_table(VHost), {'$1', User_id}),
+         User1
+  end.
+get_user_id(DBRef, VHost, User) ->
+  case ets:match(ets_users_table(VHost), {User, '$1'}) of
+       [] ->
+        IQuery = ["INSERT INTO ",users_table(VHost)," ",
+                     "SET username=\"",User,"\";"],
+        case sql_query_internal_silent(DBRef, IQuery) of
+             {updated, _} ->
+                SQuery = ["SELECT user_id FROM ",users_table(VHost)," ",
+                             "WHERE username=\"",User,"\";"],
+                {data, [[Id]]} = sql_query_internal(DBRef, SQuery),
+                ets:insert(ets_users_table(VHost), {User, Id}),
+                Id;
+             {error, Reason} ->
+                % this can be in clustered environment
+                {match, _, _} = regexp:match(Reason, "#23000"),
+                ?ERROR_MSG("Duplicate key name for ~p", [User]),
+                update_users_from_db(DBRef, VHost),
+                [[Id1]] = ets:match(ets_users_table(VHost), {User, '$1'}),
+                Id1
+        end;
+       [[Id]] -> Id
+  end.
+
+%get_server_name(DBRef, VHost, Server_id) ->
+%  case ets:match(ets_servers_table(VHost), {'$1', Server_id}) of
+%       [[Server]] -> Server;
+       % this can be in clustered environment
+%       [] ->
+%         update_servers_from_db(DBRef, VHost),
+%         [[Server1]] = ets:match(ets_servers_table(VHost), {'$1', Server_id}),
+%         Server1
+%  end.
+get_server_id(DBRef, VHost, Server) ->
+  case ets:match(ets_servers_table(VHost), {Server, '$1'}) of
+       [] ->
+        IQuery = ["INSERT INTO ",servers_table(VHost)," ",
+                     "SET server=\"",Server,"\";"],
+        case sql_query_internal_silent(DBRef, IQuery) of
+             {updated, _} ->
+                SQuery = ["SELECT server_id FROM ",servers_table(VHost)," ",
+                             "WHERE server=\"",Server,"\";"],
+                {data, [[Id]]} = sql_query_internal(DBRef, SQuery),
+                ets:insert(ets_servers_table(VHost), {Server, Id}),
+                Id;
+             {error, Reason} ->
+                % this can be in clustered environment
+                {match, _, _} = regexp:match(Reason, "#23000"),
+                ?ERROR_MSG("Duplicate key name for ~p", [Server]),
+                update_servers_from_db(DBRef, VHost),
+                [[Id1]] = ets:match(ets_servers_table(VHost), {Server, '$1'}),
+                Id1
+        end;
+       [[Id]] -> Id
+  end.
+
+%get_type_name(DBRef, VHost, Type_id) ->
+%  case ets:match(ets_types_table(VHost), {'$1', Type_id}) of
+%       [[Type]] -> Type;
+%       [] ->
+%         update_types_from_db(DBRef, VHost),
+%         [[Type1]] = ets:match(ets_types_table(VHost), {'$1', Type_id}),
+%         Type1
+%  end.
+get_type_id(DBRef, VHost, Type) ->
+  case ets:match(ets_types_table(VHost), {Type, '$1'}) of
+       [] ->
+        IQuery = ["INSERT INTO ",types_table(VHost)," ",
+                     "SET type=\"",Type,"\";"],
+        case sql_query_internal_silent(DBRef, IQuery) of
+             {updated, _} ->
+                SQuery = ["SELECT type_id FROM ",types_table(VHost)," ",
+                             "WHERE type=\"",Type,"\";"],
+                {data, [[Id]]} = sql_query_internal(DBRef, SQuery),
+                ets:insert(ets_types_table(VHost), {Type, Id}),
+                Id;
+             {error, Reason} ->
+                % this can be in clustered environment
+                {match, _, _} = regexp:match(Reason, "#23000"),
+                ?ERROR_MSG("Duplicate key name for ~p", [Type]),
+                update_types_from_db(DBRef, VHost),
+                [[Type1]] = ets:match(ets_types_table(VHost), {Type, '$1'}),
+                Type1
+        end;
+       [[Id]] -> Id
+  end.
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_logdb callbacks (maintaince)
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+rebuild_stats_at_int(DBRef, VHost, Date) ->
+    Table = table_name(VHost, Date),
+    STable = stats_table(VHost),
+
+    {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",Table," WRITE, ",
+                                                            STable," WRITE;"]),
+    Fun = fun() ->
+            DQuery = [ "DELETE FROM ",STable," ",
+                          "WHERE at='",Date,"';"],
+
+            {updated, _} = sql_query_internal(DBRef, DQuery),
+
+            SQuery = ["INSERT INTO ",STable," ",
+                       "(owner_id,at,count) ",
+                          "SELECT owner_id,\"",Date,"\"",",count(*) ",
+                             "FROM ",Table,"GROUP BY owner_id;"],
+
+            case sql_query_internal(DBRef, SQuery) of
+                 {updated, 0} ->
+                     {updated, _} = sql_query_internal(DBRef, ["DROP TABLE ",Table,";"]),
+                     ?INFO_MSG("Rebuilded stats for ~p at ~p", [VHost, Date]);
+                 {updated, _} ->
+                     ?INFO_MSG("Rebuilded stats for ~p at ~p", [VHost, Date]);
+                 _ -> ok
+            end
+          end,
+
+    % to guaranty that unlock will be done in any case
+    catch Fun(),
+
+    {updated, _} = sql_query_internal(DBRef, ["UNLOCK TABLES;"]),
+    ok.
+
+% internal
+delete_nonexistent_stats(DBRef, VHost) ->
+    Dates = get_dates_int(DBRef, VHost),
+    STable = stats_table(VHost),
+
+    Temp = lists:flatmap(fun(Date) ->
+                             ["\"",Date,"\"",","]
+                         end, Dates),
+
+    Temp1 = case Temp of
+                 [] ->
+                   ["\"\""];
+                 _ ->
+                   % replace last "," with ");"
+                   lists:append([lists:sublist(Temp, length(Temp)-1), ");"])
+            end,
+
+    Query = ["DELETE FROM ",STable," ",
+                 "WHERE at NOT IN (", Temp1],
+
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ok;
+         {error, _} ->
+            error
+    end.
+    
+%get_user_settings(DBRef, User, VHost) ->
+%    Query = ["SELECT dolog_default,dolog_list,donotlog_list FROM ",settings_table(VHost)," ",
+%                 "WHERE owner_id=\"",get_user_id(DBRef, VHost, User),"\";"],
+%    case sql_query_internal(DBRef, Query) of
+%         {data, []} ->
+%            [];
+%         {data, [[Owner, DoLogDef, DoLogL, DoNotLogL]]} ->
+%            #user_settings{owner_name=Owner,
+%                           dolog_default=mod_logdb:list_to_bool(DoLogDef),
+%                           dolog_list=binary_to_term(iolist_to_binary(DoLogL)),
+%                           donotlog_list=binary_to_term(iolist_to_binary(DoNotLogL))
+%                          };
+%         {error, _} ->
+%            error
+%    end.
+
+
+% internal
+create_stats_table(DBRef, VHost) ->
+    SName = stats_table(VHost),
+    Query = ["CREATE TABLE ",SName," (",
+                "owner_id MEDIUMINT UNSIGNED, ",
+                "at varchar(20), ",
+                "count int(11), ",
+                "INDEX(owner_id), ",
+                "INDEX(at)"
+             ") TYPE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal_silent(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created stats table for ~p", [VHost]),
+            lists:foreach(fun(Date) ->
+                            rebuild_stats_at_int(DBRef, VHost, Date)
+                          end, get_dates_int(DBRef, VHost)),
+            ok;
+         {error, Reason} ->
+            case regexp:match(Reason, "#42S01") of
+                 {match, _, _} ->
+                   ?MYDEBUG("Stats table for ~p already exists", [VHost]),
+                   ok;
+                 _ ->
+                   ?ERROR_MSG("Failed to create stats table for ~p: ~p", [VHost, Reason]),
+                   error
+            end
+    end.
+
+create_settings_table(DBRef, VHost) ->
+    SName = settings_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",SName," (",
+                "owner_id MEDIUMINT UNSIGNED, ",
+                "dolog_default TINYINT(1) NOT NULL DEFAULT 1, ",
+                "dolog_list BLOB, ",
+                "donotlog_list BLOB, ",
+                "UNIQUE INDEX(owner_id) ",
+             ") TYPE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created settings table for ~p", [VHost]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+create_users_table(DBRef, VHost) ->
+    SName = users_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",SName," (",
+                "username TEXT NOT NULL, ",
+                "user_id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE, ",
+                "UNIQUE INDEX(username(",?INDEX_SIZE,")) ",
+             ") TYPE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created users table for ~p", [VHost]),
+            ets:new(ets_users_table(VHost), [named_table, set, public]),
+            update_users_from_db(DBRef, VHost),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+update_users_from_db(DBRef, VHost) ->
+   ?INFO_MSG("Reading users from db for ~p", [VHost]),
+   SQuery = ["SELECT username, user_id FROM ",users_table(VHost),";"],
+   {data, Result} = sql_query_internal(DBRef, SQuery),
+   true = ets:delete_all_objects(ets_users_table(VHost)),
+   true = ets:insert(ets_users_table(VHost), [ {Username, User_id} || [Username, User_id] <- Result]).
+
+create_servers_table(DBRef, VHost) ->
+    SName = servers_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",SName," (",
+                "server TEXT NOT NULL, ",
+                "server_id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE, ",
+                "UNIQUE INDEX(server(",?INDEX_SIZE,")) ",
+             ") TYPE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created servers table for ~p", [VHost]),
+            ets:new(ets_servers_table(VHost), [named_table, set, public]),
+            update_servers_from_db(DBRef, VHost),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+update_servers_from_db(DBRef, VHost) ->
+   ?INFO_MSG("Reading servers from db for ~p", [VHost]),
+   SQuery = ["SELECT server, server_id FROM ",servers_table(VHost),";"],
+   {data, Result} = sql_query_internal(DBRef, SQuery),
+   true = ets:delete_all_objects(ets_servers_table(VHost)),
+   true = ets:insert(ets_servers_table(VHost), [ {Server, Server_id} || [Server, Server_id] <- Result]).
+
+create_type_table(DBRef, VHost) ->
+    SName = types_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",SName," (",
+                "type VARCHAR(20) NOT NULL, ",
+                "type_id TINYINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE, ",
+                "UNIQUE INDEX(type) ",
+             ") TYPE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created types table for ~p", [VHost]),
+            ets:new(ets_types_table(VHost), [named_table, set, public]),
+            update_types_from_db(DBRef, VHost),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+update_types_from_db(DBRef, VHost) ->
+   ?INFO_MSG("Reading types from db for ~p", [VHost]),
+   SQuery = ["SELECT type, type_id FROM ",types_table(VHost),";"],
+   {data, Result} = sql_query_internal(DBRef, SQuery),
+   true = ets:delete_all_objects(ets_types_table(VHost)),
+   true = ets:insert(ets_types_table(VHost), [ {Type, Type_id} || [Type, Type_id] <- Result]).
+
+% internal
+create_msg_table(DBRef, VHost, Date) ->
+    TName = table_name(VHost, Date),
+    Query = ["CREATE TABLE ",TName," (",
+                "owner_id MEDIUMINT UNSIGNED, ",
+                "peer_name_id MEDIUMINT UNSIGNED, ",
+                "peer_server_id MEDIUMINT UNSIGNED, ",
+                "peer_resource TEXT, ",
+                "direction TINYINT(1), ",
+                "type_id TINYINT UNSIGNED, ",
+                "subject TEXT, ",
+                "body TEXT, ",
+                "timestamp DOUBLE, ",
+                "INDEX owner_i (owner_id), ",
+                "INDEX peer_i (peer_name_id, peer_server_id) ",
+             ") TYPE=InnoDB CHARACTER SET = utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _MySQLRes} ->
+            ?MYDEBUG("Created msg table for ~p at ~p", [VHost, Date]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+% internal
+increment_user_stats(DBRef, User_id, VHost, Date) ->
+    SName = stats_table(VHost),
+    UQuery = ["UPDATE ",SName," ",
+                  "SET count=count+1 ",
+                  "WHERE owner_id=\"",User_id,"\" AND at=\"",Date,"\";"],
+
+    case sql_query_internal(DBRef, UQuery) of
+         {updated, 0} ->
+               IQuery = ["INSERT INTO ",SName," ",
+                             "(owner_id, at, count) ",
+                             "VALUES ",
+                             "('",User_id,"', '",Date,"', '1');"],
+               case sql_query_internal(DBRef, IQuery) of
+                    {updated, _} ->
+                         ?MYDEBUG("New stats for ~s@~s at ~s", [get_user_name(DBRef, VHost, User_id), VHost, Date]),
+                         ok;
+                    {error, _} ->
+                         error
+               end;
+         {updated, _} ->
+               ?MYDEBUG("Updated stats for ~s@~s at ~s", [get_user_name(DBRef, VHost, User_id), VHost, Date]),
+               ok;
+         {error, _} ->
+               error
+    end.
+
+% internal
+sql_query_internal(DBRef, Query) ->
+    case sql_query_internal_silent(DBRef, Query) of
+         {error, Reason} ->
+            ?ERROR_MSG("~p while ~p", [Reason, lists:append(Query)]),
+            {error, Reason};
+         Rez -> Rez
+    end.
+
+sql_query_internal_silent(DBRef, Query) ->
+    ?MYDEBUG("DOING: \"~s\"", [lists:append(Query)]),
+    get_result(mysql_conn:fetch(DBRef, Query, self(), ?TIMEOUT)).
+
+% internal
+get_result({updated, MySQLRes}) ->
+    {updated, mysql:get_result_affected_rows(MySQLRes)};
+get_result({data, MySQLRes}) ->
+    {data, mysql:get_result_rows(MySQLRes)};
+get_result({error, "query timed out"}) ->
+    {error, "query timed out"};
+get_result({error, MySQLRes}) ->
+    Reason = mysql:get_result_reason(MySQLRes),
+    {error, Reason}.
--- mod_logdb_mnesia_old.erl.orig	Wed Jun 13 10:26:33 2007
+++ mod_logdb_mnesia_old.erl	Tue Jun 12 20:37:32 2007
@@ -0,0 +1,244 @@
+% this backend should be used only for copy_tables functionality
+-module(mod_logdb_mnesia_old).
+
+-include("ejabberd.hrl").
+-include("jlib.hrl").
+
+-behaviour(gen_logdb).
+
+-export([start/2, stop/1,
+         log_message/2,
+         rebuild_stats/1,
+         rebuild_stats_at/2,
+         rebuild_stats_at1/2,
+         delete_messages_by_user_at/3, delete_all_messages_by_user_at/3, delete_messages_table_at/2,
+         get_vhost_stats/1, get_vhost_stats_at/2, get_user_stats/2, get_user_messages_at/3,
+         get_dates/1,
+         get_users_settings/1, set_user_settings/3]).
+
+-record(stats, {user, server, table, count}).
+-record(msg,   {to_user, to_server, to_resource, from_user, from_server, from_resource, id, type, subject, body, timestamp}).
+
+tables_prefix() -> "messages_".
+% stats_table should not start with tables_prefix(VHost) ! 
+% i.e. lists:prefix(tables_prefix(VHost), atom_to_list(stats_table())) must be /= true
+stats_table() -> list_to_atom("messages-stats").
+% table name as atom from Date
+-define(ATABLE(Date), list_to_atom(tables_prefix() ++ Date)).
+-define(LTABLE(Date), tables_prefix() ++ Date).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_logdb callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+start(_Opts, _VHost) ->
+   case mnesia:system_info(is_running) of
+        yes ->
+          ok = create_stats_table(),
+          {ok, ok};
+        no ->
+          ?ERROR_MSG("Mnesia not running", []),
+          error;
+        Status ->
+          ?ERROR_MSG("Mnesia status: ~p", [Status]),
+          error
+   end.
+
+stop(_VHost) ->
+   ok.
+
+log_message(_VHost, _Msg) ->
+   error.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_logdb callbacks (maintaince)
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+rebuild_stats(_VHost) ->
+     ok.
+
+rebuild_stats_at(VHost, Date) ->
+    Table = ?LTABLE(Date),
+    {Time, Value}=timer:tc(?MODULE, rebuild_stats_at1, [VHost, Table]),
+    ?INFO_MSG("rebuild_stats_at ~p elapsed ~p sec: ~p~n", [Date, Time/1000000, Value]),
+    Value.
+rebuild_stats_at1(VHost, Table) ->
+    CFun = fun(Msg, Stats) ->
+               To = Msg#msg.to_user ++ "@" ++ Msg#msg.to_server,
+               Stats_to = if 
+                            Msg#msg.to_server == VHost ->
+                               case lists:keysearch(To, 1, Stats) of
+                                    {value, {Who_to, Count_to}} ->
+                                       lists:keyreplace(To, 1, Stats, {Who_to, Count_to + 1});
+                                    false ->
+                                        lists:append(Stats, [{To, 1}])
+                               end;
+                            true ->
+                               Stats
+                          end,
+               From = Msg#msg.from_user ++ "@" ++ Msg#msg.from_server,
+               Stats_from = if
+                              Msg#msg.from_server == VHost  ->
+                                 case lists:keysearch(From, 1, Stats_to) of
+                                      {value, {Who_from, Count_from}} ->
+                                         lists:keyreplace(From, 1, Stats_to, {Who_from, Count_from + 1});
+                                      false ->
+                                         lists:append(Stats_to, [{From, 1}])
+                                 end;
+                              true ->
+                                 Stats_to
+                            end,
+               Stats_from
+           end,
+    DFun = fun(#stats{table=STable, server=Server} = Stat, _Acc)
+                when STable == Table, Server == VHost ->
+                 mnesia:delete_object(stats_table(), Stat, write);
+              (_Stat, _Acc) -> ok
+           end,
+    case mnesia:transaction(fun() ->
+                               mnesia:write_lock_table(list_to_atom(Table)),
+                               mnesia:write_lock_table(stats_table()),
+                               % Calc stats for VHost at Date
+                               AStats = mnesia:foldl(CFun, [], list_to_atom(Table)),
+                               % Delete all stats for VHost at Date
+                               mnesia:foldl(DFun, [], stats_table()),
+                               % Write new calc'ed stats
+                               lists:foreach(fun({Who, Count}) ->
+                                                 Jid = jlib:string_to_jid(Who),
+                                                 JUser = Jid#jid.user,
+                                                 WStat = #stats{user=JUser, server=VHost, table=Table, count=Count},
+                                                 mnesia:write(stats_table(), WStat, write)
+                                             end, AStats)
+                            end) of
+         {aborted, Reason} ->
+              ?ERROR_MSG("Failed to rebuild_stats_at for ~p at ~p: ~p", [VHost, Table, Reason]),
+              error;
+         {atomic, _} ->
+              ok
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_logdb callbacks (delete)
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+delete_messages_by_user_at(_VHost, _Msgs, _Date) ->
+    error.
+
+delete_all_messages_by_user_at(_User, _VHost, _Date) ->
+    error.
+
+delete_messages_table_at(VHost, Date) ->
+   Table = list_to_atom(tables_prefix() ++ Date),
+
+   DFun = fun(#msg{to_server=To_server, from_server=From_server}=Msg, _Acc)
+                when To_server == VHost; From_server == VHost ->
+                   mnesia:delete_object(Table, Msg, write);
+             (_Msg, _Acc) -> ok
+          end,
+   
+   case mnesia:transaction(fun() ->
+                            mnesia:foldl(DFun, [], Table)
+                           end) of
+        {aborted, Reason} ->
+            ?ERROR_MSG("Failed to delete_messages_table_at for ~p at ~p: ~p", [VHost, Date, Reason]),
+            error;
+        {atomic, _} ->
+            ok
+   end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_logdb callbacks (get)
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+get_vhost_stats(_VHost) ->
+    {error, "does not emplemented"}.
+
+get_vhost_stats_at(VHost, Date) ->
+    Fun = fun() ->
+             Pat = #stats{user='$1', server=VHost, table=tables_prefix()++Date, count = '$2'},
+             mnesia:select(stats_table(), [{Pat, [], [['$1', '$2']]}])
+          end,
+    case mnesia:transaction(Fun) of
+         {atomic, Result} ->
+                   RFun = fun([User, Count]) ->
+                             {User, Count}
+                          end,
+                   {ok, lists:reverse(lists:keysort(2, lists:map(RFun, Result)))};
+         {aborted, Reason} -> {error, Reason}
+    end.
+
+get_user_stats(_User, _VHost) ->
+    {error, "does not emplemented"}.
+
+get_user_messages_at(User, VHost, Date) ->
+    Table_name = tables_prefix() ++ Date,
+    case mnesia:transaction(fun() ->
+                               Pat_to = #msg{to_user=User, to_server=VHost, _='_'},
+                               Pat_from = #msg{from_user=User, from_server=VHost,  _='_'},
+                               mnesia:select(list_to_atom(Table_name),
+                                             [{Pat_to, [], ['$_']},
+                                              {Pat_from, [], ['$_']}])
+                       end) of
+          {atomic, Result} ->
+                   Msgs = lists:map(fun(#msg{to_user=To_user, to_server=To_server, to_resource=To_res,
+                                             from_user=From_user, from_server=From_server, from_resource=From_res,
+                                             type=Type,
+                                             subject=Subj,
+                                             body=Body, timestamp=Timestamp} = _Msg) ->
+                                        Subject = case Subj of
+                                                       "None" -> "";
+                                                       _ -> Subj
+                                                  end,
+                                        {msg, To_user, To_server, To_res, From_user, From_server, From_res, Type, Subject, Body, Timestamp}
+                                    end, Result),
+                   {ok, Msgs};
+          {aborted, Reason} ->
+                   {error, Reason}
+    end.
+
+get_dates(_VHost) ->
+    Tables = mnesia:system_info(tables),
+    MessagesTables =
+        lists:filter(fun(Table) ->
+                         lists:prefix(tables_prefix(), atom_to_list(Table))
+                     end,
+                     Tables),
+    lists:map(fun(Table) ->
+                  lists:sublist(atom_to_list(Table),
+                                length(tables_prefix())+1,
+                                length(atom_to_list(Table)))
+              end,
+              MessagesTables).
+
+get_users_settings(_VHost) ->
+    {ok, []}.
+set_user_settings(_User, _VHost, _Set) ->
+    ok.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% internal 
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% called from db_logon/2
+create_stats_table() ->
+    SName = stats_table(),
+    case mnesia:create_table(SName,
+                             [{disc_only_copies, [node()]},
+                              {type, bag},
+                              {attributes, record_info(fields, stats)},
+                              {record_name, stats}
+                             ]) of
+         {atomic, ok} ->
+             ?INFO_MSG("Created stats table", []),
+             ok;
+         {aborted, {already_exists, _}} ->
+             ok;
+         {aborted, Reason} ->
+             ?ERROR_MSG("Failed to create stats table: ~p", [Reason]),
+             error
+    end.
--- gen_logdb.erl.orig	Wed Jun 13 10:26:33 2007
+++ gen_logdb.erl	Mon Jun 11 21:41:35 2007
@@ -0,0 +1,152 @@
+-module(gen_logdb).
+
+-export([behaviour_info/1]).
+
+behaviour_info(callbacks) ->
+   [
+    % called from handle_info(start, _)
+    % it should logon database and return reference to started instance
+    % start(VHost, Opts) -> {ok, SPid} | error
+    %  Options - list of options to connect to db
+    %    Types: Options = list() -> [] |
+    %                              [{user, "logdb"},
+    %                               {pass, "1234"},
+    %                               {db, "logdb"}] | ...
+    %          VHost = list() -> "jabber.example.org"
+    {start, 2},
+
+    % called from cleanup/1
+    % it should logoff database and do cleanup
+    % stop(VHost)
+    %    Types: VHost = list() -> "jabber.example.org"
+    {stop, 1},
+
+    % called from handle_call({addlog, _}, _, _)
+    % it should log messages to database
+    % log_message(VHost, Msg) -> ok | error
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          Msg = record() -> #msg
+    {log_message, 2},
+
+    % called from ejabberdctl rebuild_stats
+    % it should rebuild stats table (if used) for vhost
+    % rebuild_stats(VHost)
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    {rebuild_stats, 1},
+
+    % it should rebuild stats table (if used) for vhost at Date
+    % rebuild_stats_at(VHost, Date)
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          Date = list() -> "2007-02-12"
+    {rebuild_stats, 1},
+
+    % called from user_messages_at_parse_query/5
+    % it should delete selected user messages at date
+    % delete_messages_by_user_at(VHost, Msgs, Date) -> ok | error
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          Msgs = list() -> [ #msg1, msg2, ... ]
+    %          Date = list() -> "2007-02-12"
+    {delete_messages_by_user_at, 3},
+
+    % called from user_messages_parse_query/4 | vhost_messages_at_parse_query/4
+    % it should delete all user messages at date
+    % delete_all_messages_by_user_at(User, VHost, Date) -> ok | error
+    %    Types:
+    %          User = list() -> "admin"
+    %          VHost = list() -> "jabber.example.org"
+    %          Date = list() -> "2007-02-12"
+    {delete_all_messages_by_user_at, 3},
+
+    % called from vhost_messages_parse_query/3
+    % it should delete messages table for vhost at date and update stats
+    % delete_messages_table_at(VHost, Date) -> ok | error
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          Date = list() -> "2007-02-12"
+    {delete_messages_table_at, 2},
+
+    % called from ejabberd_web_admin:vhost_messages_stats/3
+    % it should return sorted list of count of messages by dates for vhost
+    % get_vhost_stats(VHost) -> {ok, [{Date1, Msgs_count1}, {Date2, Msgs_count2}, ... ]} |
+    %                           {error, Reason}
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          DateN = list() -> "2007-02-12"
+    %          Msgs_countN = number() -> 241
+    {get_vhost_stats, 1},
+
+    % called from ejabberd_web_admin:vhost_messages_stats_at/4
+    % it should return sorted list of count of messages by users at date for vhost
+    % get_vhost_stats_at(VHost, Date) -> {ok, [{User1, Msgs_count1}, {User2, Msgs_count2}, ....]} |
+    %                                    {error, Reason}
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          Date = list() -> "2007-02-12"
+    %          UserN = list() -> "admin"
+    %          Msgs_countN = number() -> 241
+    {get_vhost_stats_at, 2},
+
+    % called from ejabberd_web_admin:user_messages_stats/4
+    % it should return sorted list of count of messages by date for user at vhost
+    % get_user_stats(User, VHost) -> {ok, [{Date1, Msgs_count1}, {Date2, Msgs_count2}, ...]} |
+    %                                {error, Reason}
+    %    Types:
+    %          User = list() -> "admin"
+    %          VHost = list() -> "jabber.example.org"
+    %          DateN = list() -> "2007-02-12"
+    %          Msgs_countN = number() -> 241
+    {get_user_stats, 2},
+
+    % called from ejabberd_web_admin:user_messages_stats_at/5
+    % it should return all user messages at date
+    % get_user_messages_at(User, VHost, Date) -> {ok, Msgs} | {error, Reason}
+    %    Types:
+    %          User = list() -> "admin"
+    %          VHost = list() -> "jabber.example.org"
+    %          Date = list() -> "2007-02-12"
+    %          Msgs = list() -> [ #msg1, msg2, ... ]
+    {get_user_messages_at, 3},
+
+    % called from many places
+    % it should return list of dates for vhost
+    % get_dates(VHost) -> ["Date1", "Date2", ... ]
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          DateN = list() -> "2007-02-12"
+    {get_dates, 1},
+
+    % called from start
+    % it should return list with users settings for VHost in db
+    % get_users_settings(VHost) -> [{User, true | false}, ... ]
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          User = list() -> "admin"
+    {get_users_settings, 1},
+
+    % called from many places
+    % it should return either to log message or not for User at VHost from db
+    % get_user_settings(User, VHost) -> Result
+    %    Types:
+    %          User = list() -> "admin"
+    %          VHost = list() -> "jabber.example.org"
+    %          Result = true (do log)
+    %                   false (do not log)
+    %                   [] (undefined)
+    %                   error (on error)
+    %{get_user_settings, 2},
+
+    % called from web admin
+    % it should set either to log message or not for User at VHost
+    % set_user_settings(User, VHost, Set) -> ok | error
+    %    Types:
+    %          User = list() -> "admin"
+    %          VHost = list() -> "jabber.example.org"
+    %          Set = true | false
+    {set_user_settings, 3}
+   ];
+behaviour_info(_) ->
+   undefined.
--- web/ejabberd_web_admin-1.1.2.erl	Thu Apr 26 16:04:49 2007
+++ web/ejabberd_web_admin.erl	Wed Jun 13 10:26:09 2007
@@ -21,6 +21,7 @@
 -include("ejabberd.hrl").
 -include("jlib.hrl").
 -include("ejabberd_http.hrl").
+-include("mod_logdb.hrl").
 
 -define(X(Name), {xmlelement, Name, [], []}).
 -define(XA(Name, Attrs), {xmlelement, Name, Attrs, []}).
@@ -46,6 +47,11 @@
 	?XA("input", [{"type", Type},
 		      {"name", Name},
 		      {"value", Value}])).
+-define(INPUTC(Type, Name, Value),
+        ?XA("input", [{"type", Type},
+                      {"name", Name},
+                      {"value", Value},
+                      {"checked", "true"}])).
 -define(INPUTT(Type, Name, Value), ?INPUT(Type, Name, ?T(Value))).
 -define(INPUTS(Type, Name, Value, Size),
 	?XA("input", [{"type", Type},
@@ -137,6 +143,12 @@
 				    [?LI([?ACT(Base ++ "shared-roster/", "Shared Roster")])];
 				false ->
 				    []
+			    end ++
+			    case gen_mod:is_loaded(Host, mod_logdb) of
+			        true ->
+				    [?LI([?ACT(Base ++ "messages/", "Users Messages")])];
+				false ->
+				    []
 			    end
 			   )]),
 		  ?XAE("div",
@@ -564,6 +576,12 @@
 			    [?LI([?ACT(Base ++ "shared-roster/", "Shared Roster")])];
 			false ->
 			    []
+		    end ++
+		    case gen_mod:is_loaded(Host, mod_logdb) of
+			true ->
+			    [?LI([?ACT(Base ++ "messages/", "Users Messages")])];
+			false ->
+			    []
 		    end
 		   )
 	       ], Host, Lang);
@@ -925,6 +943,38 @@
     make_xhtml(Res, Host, Lang);
 
 process_admin(Host,
+              #request{us = US,
+                       path = ["messages"], 
+                       q = Query, 
+                       lang = Lang} = Request) when is_list(Host) ->
+    Res = vhost_messages_stats(Host, Query, Lang),
+    make_xhtml(Res, Host, Lang);
+
+process_admin(Host,
+              #request{us = US,
+                       path = ["messages", Date],
+                       q = Query,
+                       lang = Lang} = Request) when is_list(Host) ->
+    Res = vhost_messages_stats_at(Host, Query, Lang, Date),
+    make_xhtml(Res, Host, Lang);
+
+process_admin(Host,
+              #request{us = US,
+                       path = ["user", U, "messages"],
+                       q = Query,
+                       lang = Lang} = Request) ->
+    Res = user_messages_stats(U, Host, Query, Lang),
+    make_xhtml(Res, Host, Lang);
+
+process_admin(Host,
+              #request{us = US,
+                       path = ["user", U, "messages", Date],
+                       q = Query,
+                       lang = Lang} = Request) ->
+    Res = user_messages_stats_at(U, Host, Query, Lang, Date),
+    make_xhtml(Res, Host, Lang);
+
+process_admin(Host,
 	      #request{us = US,
 		       path = ["user", U, "roster"],
 		       q = Query,
@@ -1442,6 +1492,22 @@
 	      [?XCT("h3", "Password:")] ++ FPassword ++
 	      [?XCT("h3", "Offline Messages:")] ++ FQueueLen ++
 	      [?XE("h3", [?ACT("roster/", "Roster")])] ++
+	      case gen_mod:is_loaded(Server, mod_logdb) of
+		true ->
+                   Sett = mod_logdb:get_user_settings(User, Server),
+                   Log =
+                     case Sett#user_settings.dolog_default of
+                          false ->
+                             ?INPUTT("submit", "dolog", "Log Messages");
+                          true -> 
+                             ?INPUTT("submit", "donotlog", "Do Not Log Messages");
+                          _ -> []
+                     end,
+	  	   [?XE("h3", [?ACT("messages/", "Messages"), ?C(" "), Log])];
+                   %[?INPUT("test", "test", "test"), ?C(" "), Log];
+		false ->
+		   []
+	      end ++
 	      [?BR, ?INPUTT("submit", "removeuser", "Remove User")])].
 
 
@@ -1462,8 +1528,22 @@
 		{value, _} ->
 		    ejabberd_auth:remove_user(User, Server),
 		    ok;
-		false ->
-		    nothing
+		_ ->
+		    case lists:keysearch("dolog", 1, Query) of
+                         {value, _} ->
+                           Sett = mod_logdb:get_user_settings(User, Server),
+                           mod_logdb:set_user_settings(User, Server, Sett#user_settings{dolog_default=true}),
+                           nothing;
+                         _ ->
+                           case lists:keysearch("donotlog", 1, Query) of
+                                {value, _} ->
+                                    Sett = mod_logdb:get_user_settings(User, Server),
+                                    mod_logdb:set_user_settings(User, Server, Sett#user_settings{dolog_default=false}),
+                                    nothing;
+                                false ->
+                                    nothing
+                           end
+                    end
 	    end
     end.
 
@@ -1574,6 +1654,14 @@
     Res = user_roster_parse_query(User, Server, Items1, Query, Admin),
     Items = mnesia:dirty_index_read(roster, US, #roster.us),
     SItems = lists:sort(Items),
+
+    Settings = case gen_mod:is_loaded(Server, mod_logdb) of
+         true ->
+             mod_logdb:get_user_settings(User, Server);
+         false ->
+             []
+    end,
+
     FItems =
 	case SItems of
 	    [] ->
@@ -1621,7 +1709,33 @@
 					      [?INPUTT("submit",
 						       "remove" ++
 						       term_to_id(R#roster.jid),
-						       "Remove")])])
+						       "Remove")]),
+                                         case gen_mod:is_loaded(Server, mod_logdb) of
+                                              true ->
+                                                 Peer = jlib:jid_to_string(R#roster.jid),
+                                                 A = lists:member(Peer, Settings#user_settings.dolog_list),
+                                                 B = lists:member(Peer, Settings#user_settings.donotlog_list),
+                                                 {Name, Value} =
+                                                   if
+                                                     A ->
+                                                       {"donotlog", "Do Not Log Messages"};
+                                                     B ->
+                                                       {"dolog", "Log Messages"};
+                                                     Settings#user_settings.dolog_default == true ->
+                                                       {"donotlog", "Do Not Log Messages"};
+                                                     Settings#user_settings.dolog_default == false ->
+                                                       {"dolog", "Log Messages"}
+                                                   end,
+
+                                                 ?XAE("td", [{"class", "valign"}],
+                                                      [?INPUTT("submit",
+                                                               Name ++
+                                                               term_to_id(R#roster.jid),
+                                                               Value)]);
+                                              false ->
+                                                 ?X([])
+                                         end
+                                        ])
 			    end, SItems))])]
 	end,
     [?XC("h1", ?T("Roster of ") ++ us_to_list(US))] ++
@@ -1637,6 +1751,288 @@
 	       ?INPUTT("submit", "addjid", "Add Jabber ID")
 	      ])].
 
+vhost_messages_stats(Server, Query, Lang) ->
+    Res = case catch mod_logdb:vhost_messages_parse_query(Server, Query) of
+                     {'EXIT', Reason} -> 
+                         ?ERROR_MSG("~p", [Reason]),
+                         error;
+                     VResult -> VResult
+          end,
+    {Time, Value} = timer:tc(mod_logdb, get_vhost_stats, [Server]),
+    ?INFO_MSG("get_vhost_stats(~p) elapsed ~p sec", [Server, Time/1000000]),
+    %case mod_logdb:get_vhost_stats(Server) of
+    case Value of
+         {'EXIT', CReason} ->
+              ?ERROR_MSG("Failed to get_vhost_stats: ~p", [CReason]),
+              [?XC("h1", ?T("Error occupied while fetching list"))];
+         {error, GReason} ->
+              ?ERROR_MSG("Failed to get_vhost_stats: ~p", [GReason]),
+              [?XC("h1", ?T("Error occupied while fetching list"))];
+         {ok, []} ->
+              [?XC("h1", ?T("No logged messages for ") ++ Server)];
+         {ok, Dates} ->
+              Fun = fun({Date, Count}) ->
+                         ID = jlib:encode_base64(binary_to_list(term_to_binary(Server++Date))),
+                         ?XE("tr",
+                          [?XE("td", [?INPUT("checkbox", "selected", ID)]),
+                           ?XE("td", [?AC(Date, Date)]),
+                           ?XC("td", integer_to_list(Count))
+                          ])
+                    end,
+              [?XC("h1", ?T("Logged messages for ") ++ Server)] ++
+               case Res of
+                    ok -> [?CT("Submitted"), ?P];
+                    error -> [?CT("Bad format"), ?P];
+                    nothing -> []
+               end ++
+               [?XAE("form", [{"action", ""}, {"method", "post"}],
+                [?XE("table",
+                 [?XE("thead",
+                  [?XE("tr",
+                   [?X("td"),
+                    ?XCT("td", "Date"),
+                    ?XCT("td", "Count")
+                   ])]),
+                  ?XE("tbody",
+                      lists:map(Fun, Dates)
+                     )]),
+                  ?BR,
+                  ?INPUTT("submit", "delete", "Delete Selected")
+                ])]
+   end.
+
+vhost_messages_stats_at(Server, Query, Lang, Date) ->
+   {Time, Value} = timer:tc(mod_logdb, get_vhost_stats_at, [Server, Date]),
+   ?INFO_MSG("get_vhost_stats_at(~p,~p) elapsed ~p sec", [Server, Date, Time/1000000]),
+   %case mod_logdb:get_vhost_stats_at(Server, Date) of
+   case Value of
+        {'EXIT', CReason} ->
+             ?ERROR_MSG("Failed to get_vhost_stats_at: ~p", [CReason]),
+             [?XC("h1", ?T("Error occupied while fetching list"))];
+        {error, GReason} ->
+             ?ERROR_MSG("Failed to get_vhost_stats_at: ~p", [GReason]),
+             [?XC("h1", ?T("Error occupied while fetching list"))];
+        {ok, []} ->
+             [?XC("h1", ?T("No logged messages for ") ++ Server ++ ?T(" at ") ++ Date)];
+        {ok, Users} ->
+             Res = case catch mod_logdb:vhost_messages_at_parse_query(Server, Date, Users, Query) of
+                        {'EXIT', Reason} ->
+                            ?ERROR_MSG("~p", [Reason]),
+                            error;
+                        VResult -> VResult
+                   end,
+             Fun = fun({User, Count}) ->
+                         ID = jlib:encode_base64(binary_to_list(term_to_binary(User++Server))),
+                         ?XE("tr",
+                          [?XE("td", [?INPUT("checkbox", "selected", ID)]),
+                           ?XE("td", [?AC("../user/"++User++"/messages/"++Date, User)]),
+                           ?XC("td", integer_to_list(Count))
+                          ])
+                   end,
+             [?XC("h1", ?T("Logged messages for ") ++ Server ++ ?T(" at ") ++ Date)] ++
+              case Res of
+                    ok -> [?CT("Submitted"), ?P];
+                    error -> [?CT("Bad format"), ?P];
+                    nothing -> []
+              end ++
+              [?XAE("form", [{"action", ""}, {"method", "post"}],
+                [?XE("table",
+                 [?XE("thead",
+                  [?XE("tr",
+                   [?X("td"),
+                    ?XCT("td", "User"),
+                    ?XCT("td", "Count")
+                   ])]),
+                  ?XE("tbody",
+                      lists:map(Fun, Users)
+                     )]),
+                  ?BR,
+                  ?INPUTT("submit", "delete", "Delete Selected")
+                ])]
+   end.
+
+user_messages_stats(User, Server, Query, Lang) ->
+    US = {jlib:nodeprep(User), jlib:nameprep(Server)},
+    Jid = us_to_list(US),
+
+    Res = case catch mod_logdb:user_messages_parse_query(User, Server, Query) of
+               {'EXIT', Reason} -> 
+                    ?ERROR_MSG("~p", [Reason]),
+                    error;
+               VResult -> VResult
+          end,
+
+   {Time, Value} = timer:tc(mod_logdb, get_user_stats, [User, Server]),
+   ?INFO_MSG("get_user_stats(~p,~p) elapsed ~p sec", [User, Server, Time/1000000]),
+
+   case Value of
+        {'EXIT', CReason} ->
+            ?ERROR_MSG("Failed to get_user_stats: ~p", [CReason]),
+            [?XC("h1", ?T("Error occupied while fetching days"))];
+        {error, GReason} ->
+            ?ERROR_MSG("Failed to get_user_stats: ~p", [GReason]),
+            [?XC("h1", ?T("Error occupied while fetching days"))];
+        {ok, []} ->
+            [?XC("h1", ?T("No logged messages for ") ++ Jid)];
+        {ok, Dates} ->
+            Fun = fun({Date, Count}) ->
+                      ID = jlib:encode_base64(binary_to_list(term_to_binary(User++Date))),
+                      ?XE("tr",
+                       [?XE("td", [?INPUT("checkbox", "selected", ID)]),
+                        ?XE("td", [?AC(Date, Date)]),
+                        ?XC("td", integer_to_list(Count))
+                       ])
+                       %[?AC(Date, Date ++ " (" ++ integer_to_list(Count) ++ ")"), ?BR]
+                  end,
+            [?XC("h1", ?T("Logged messages for ") ++ Jid)] ++
+             case Res of
+                   ok -> [?CT("Submitted"), ?P];
+                   error -> [?CT("Bad format"), ?P];
+                   nothing -> []
+             end ++
+             [?XAE("form", [{"action", ""}, {"method", "post"}],
+              [?XE("table",
+               [?XE("thead",
+                [?XE("tr",
+                 [?X("td"),
+                  ?XCT("td", "Date"),
+                  ?XCT("td", "Count")
+                 ])]),
+                ?XE("tbody",
+                    lists:map(Fun, Dates)
+                   )]),
+                ?BR,
+                ?INPUTT("submit", "delete", "Delete Selected")
+              ])]
+    end.
+
+user_messages_stats_at(User, Server, Query, Lang, Date) ->
+   US = {jlib:nodeprep(User), jlib:nameprep(Server)},
+   Jid = us_to_list(US),
+
+   {Time, Value} = timer:tc(mod_logdb, get_user_messages_at, [User, Server, Date]),
+   ?INFO_MSG("get_user_messages_at(~p,~p,~p) elapsed ~p sec", [User, Server, Date, Time/1000000]),
+   case Value of
+        {'EXIT', CReason} ->
+           ?ERROR_MSG("Failed to get_user_messages_at: ~p", [CReason]),
+           [?XC("h1", ?T("Error occupied while fetching messages"))];
+        {error, GReason} ->
+           ?ERROR_MSG("Failed to get_user_messages_at: ~p", [GReason]),
+           [?XC("h1", ?T("Error occupied while fetching messages"))];
+        {ok, []} ->
+           [?XC("h1", ?T("No logged messages for ") ++ Jid ++ ?T(" at ") ++ Date)];
+        {ok, User_messages} ->
+           Res =  case catch mod_logdb:user_messages_at_parse_query(Server,
+                                                                    Date,
+                                                                    User_messages,
+                                                                    Query) of
+                       {'EXIT', Reason} ->
+                            ?ERROR_MSG("~p", [Reason]),
+                            error;
+                       VResult -> VResult
+                  end,
+
+           UniqUsers = lists:foldl(fun(#msg{peer_name=PName, peer_server=PServer}, List) ->
+                                 case lists:member(PName++"@"++PServer, List) of
+                                      true -> List;
+                                      false -> lists:append([PName++"@"++PServer], List)
+                                 end
+                               end, [], User_messages),
+
+           % Users to filter (sublist of UniqUsers)
+           CheckedUsers = case lists:keysearch("filter", 1, Query) of
+                           {value, _} ->
+                              lists:filter(fun(UFUser) ->
+                                                ID = jlib:encode_base64(binary_to_list(term_to_binary(UFUser))),
+                                                lists:member({"selected", ID}, Query)
+                                           end, UniqUsers);
+                           false -> []
+                         end,
+
+           % UniqUsers in html (noone selected -> everyone selected)
+           Users = lists:map(fun(UHUser) ->
+                                ID = jlib:encode_base64(binary_to_list(term_to_binary(UHUser))),
+                                Input = case lists:member(UHUser, CheckedUsers) of
+                                         true -> [?INPUTC("checkbox", "selected", ID)];
+                                         false when CheckedUsers == [] -> [?INPUTC("checkbox", "selected", ID)];
+                                         false -> [?INPUT("checkbox", "selected", ID)]
+                                        end,
+                                ?XE("tr",
+                                 [?XE("td", Input),
+                                  ?XC("td", UHUser)])
+                             end, lists:sort(UniqUsers)),
+
+           % Messages to show (based on Users)
+           User_messages_filtered = case CheckedUsers of
+                                         [] -> User_messages;
+                                         _  -> lists:filter(fun(#msg{peer_name=PName, peer_server=PServer}) ->
+                                                  lists:member(PName++"@"++PServer, CheckedUsers)
+                                               end, User_messages)
+                                    end,
+
+           Msgs_Fun = fun(#msg{timestamp=Timestamp,
+                               subject=Subject,
+                               direction=Direction,
+                               peer_name=PName, peer_server=PServer, peer_resource=PRes,
+                               body=Body}) ->
+                      TextRaw = case Subject of
+                                     "" -> Body;
+                                     _ -> [?T("Subject"),": ",Subject,"<br>", Body]
+                                end,
+                      ID = jlib:encode_base64(binary_to_list(term_to_binary(Timestamp))),
+                      % replace \n with <br>
+                      Text = lists:map(fun(10) -> "<br>";
+                                           (A) -> A
+                                        end, TextRaw),
+                      Resource = case PRes of
+                                      [] -> [];
+                                      undefined -> [];
+                                      R -> "/" ++ R
+                                 end,
+                      ?XE("tr",
+                       [?XE("td", [?INPUT("checkbox", "selected", ID)]),
+                        ?XC("td", mod_logdb:convert_timestamp(Timestamp)),
+                        ?XC("td", atom_to_list(Direction)++": "++PName++"@"++PServer++Resource),
+                        ?XC("td", Text)])
+                 end,
+           % Filtered user messages in html
+           Msgs = lists:map(Msgs_Fun, lists:sort(User_messages_filtered)),
+
+           [?XC("h1", ?T("Logged messages for ") ++ Jid ++ ?T(" at ") ++ Date)] ++
+            case Res of
+                 ok -> [?CT("Submitted"), ?P];
+                 error -> [?CT("Bad format"), ?P];
+                 nothing -> []
+            end ++
+            [?XAE("form", [{"action", ""}, {"method", "post"}],
+             [?XE("table",
+                  [?XE("thead",
+                       [?X("td"),
+                        ?XCT("td", "User")
+                       ]
+                      ),
+                   ?XE("tbody",
+                        Users
+                      )]),
+              ?INPUTT("submit", "filter", "Filter Selected")
+             ] ++
+             [?XE("table",
+                  [?XE("thead",
+                       [?XE("tr",
+                        [?X("td"),
+                         ?XCT("td", "Date, Time"),
+                         ?XCT("td", "Direction: Jid"),
+                         ?XCT("td", "Body")
+                        ])]),
+                   ?XE("tbody",
+                        Msgs
+                      )]),
+              ?INPUTT("submit", "delete", "Delete Selected"),
+              ?BR
+             ]
+            )]
+    end.
+
 user_roster_parse_query(User, Server, Items, Query, Admin) ->
     case lists:keysearch("addjid", 1, Query) of
 	{value, _} ->
@@ -1704,10 +2100,39 @@
 						[]}]}}),
 			      throw(submitted);
 			  false ->
-			      ok
-		      end
-
-	      end
+                            case lists:keysearch(
+                                   "donotlog" ++ term_to_id(JID), 1, Query) of
+                                {value, _} ->
+                                     Peer = jlib:jid_to_string(JID),
+                                     Settings = mod_logdb:get_user_settings(User, Server),
+                                     DNLL = case lists:member(Peer, Settings#user_settings.donotlog_list) of
+                                                 false -> lists:append(Settings#user_settings.donotlog_list, [Peer]);
+                                                 true -> Settings#user_settings.donotlog_list
+                                            end,
+                                     DLL = lists:delete(jlib:jid_to_string(JID), Settings#user_settings.dolog_list),
+                                     Sett = Settings#user_settings{donotlog_list=DNLL, dolog_list=DLL},
+                                     ok = mod_logdb:set_user_settings(User, Server, Sett),
+                                     throw(nothing);
+                                false ->
+                                   case lists:keysearch(
+ 				          "dolog" ++ term_to_id(JID), 1, Query) of
+ 				       {value, _} ->
+                                          Peer = jlib:jid_to_string(JID),
+                                          Settings = mod_logdb:get_user_settings(User, Server),
+                                          DLL = case lists:member(Peer, Settings#user_settings.dolog_list) of
+                                                     false -> lists:append(Settings#user_settings.dolog_list, [Peer]);
+                                                     true -> Settings#user_settings.dolog_list
+                                                end,
+                                          DNLL = lists:delete(jlib:jid_to_string(JID), Settings#user_settings.donotlog_list),
+                                          Sett = Settings#user_settings{donotlog_list=DNLL, dolog_list=DLL},
+                                          ok = mod_logdb:set_user_settings(User, Server, Sett),
+                                          throw(nothing);
+				       false ->
+				           ok
+			           end % dolog
+                            end % donotlog
+	              end % remove
+	      end % validate
       end, Items),
     nothing.
 
--- mod_muc/mod_muc_room-1.1.2.erl	Thu Jun  7 16:04:07 2007
+++ mod_muc/mod_muc_room.erl	Mon Jun 11 15:50:20 2007
@@ -648,6 +648,12 @@
 		    false
 	    end,
     {reply, Reply, StateName, StateData};
+handle_sync_event({get_jid_nick, Jid}, _From, StateName, StateData) ->
+    R = case ?DICT:find(jlib:jid_tolower(Jid), StateData#state.users) of
+             error -> [];
+             {ok, {user, _, Nick, _, _}} -> Nick
+        end,
+    {reply, R, StateName, StateData};
 handle_sync_event(_Event, _From, StateName, StateData) ->
     Reply = ok,
     {reply, Reply, StateName, StateData}.
--- ejabberd_ctl-1.1.2.erl	Thu Apr 26 17:59:45 2007
+++ ejabberd_ctl.erl	Fri May 18 17:40:13 2007
@@ -260,7 +260,7 @@
 print_vhost_usage(Host) ->
     CmdDescs =
 	ets:select(ejabberd_ctl_host_cmds,
-		   [{{Host, '$1', '$2'}, [], [{{'$1', '$2'}}]}]),
+		   [{{{Host, '$1'}, '$2'}, [], [{{'$1', '$2'}}]}]),
     MaxCmdLen =
 	if
 	    CmdDescs == [] ->
@@ -294,7 +294,7 @@
 
 register_commands(Host, CmdDescs, Module, Function) ->
     ets:insert(ejabberd_ctl_host_cmds,
-	       [{Host, Cmd, Desc} || {Cmd, Desc} <- CmdDescs]),
+	       [{{Host, Cmd}, Desc} || {Cmd, Desc} <- CmdDescs]),
     ejabberd_hooks:add(ejabberd_ctl_process, Host,
 		       Module, Function, 50),
     ok.
@@ -310,7 +310,7 @@
 unregister_commands(Host, CmdDescs, Module, Function) ->
     lists:foreach(fun({Cmd, Desc}) ->
 			  ets:delete_object(ejabberd_ctl_host_cmds,
-					    {Host, Cmd, Desc})
+					    {{Host, Cmd}, Desc})
 		  end, CmdDescs),
     ejabberd_hooks:delete(ejabberd_ctl_process,
 			  Module, Function, 50),
@@ -320,7 +320,7 @@
     dump_to_textfile(mnesia:system_info(is_running), file:open(File, write)).
 dump_to_textfile(yes, {ok, F}) ->
     Tabs1 = lists:delete(schema, mnesia:system_info(local_tables)),
-    Tabs = lists:filter(
+    Tabs2 = lists:filter(
 	     fun(T) ->
 		     case mnesia:table_info(T, storage_type) of
 			 disc_copies -> true;
@@ -328,6 +328,10 @@
 			 _ -> false
 		     end
 	     end, Tabs1),
+    Tabs = lists:filter(
+             fun(T) ->
+                  not lists:prefix("messages", atom_to_list(T))
+             end, Tabs2),
     Defs = lists:map(
 	     fun(T) -> {T, [{record_name, mnesia:table_info(T, record_name)},
 			    {attributes, mnesia:table_info(T, attributes)}]} 
--- msgs/uk-1.1.2.msg	Thu Apr 26 16:04:49 2007
+++ msgs/uk.msg	Wed Jun 13 10:26:33 2007
@@ -371,6 +371,20 @@
 {"Virtual Hosts", " "}.
 {"ejabberd virtual hosts", "  ejabberd"}.
 {"Host", ""}.
+{"Users Messages", " "}.
+{"Date", ""}.
+{"Count", ""}.
+{"Logged messages for ", "   "}.
+{" at ", "  "}.
+{"No logged messages for ", "   "}.
+{"Date, Time", ", "}.
+{"Direction: Jid", ": Jid"}.
+{"Subject", ""}.
+{"Body", ""}.
+{"Messages", ""}.
+{"Filter Selected", " "}.
+{"Do Not Log Messages", "  "}.
+{"Log Messages", " "}.
 
 % Local Variables:
 % mode: erlang
--- msgs/ru-1.1.2.msg	Thu Apr 26 16:04:49 2007
+++ msgs/ru.msg	Wed Jun 13 10:26:33 2007
@@ -371,6 +371,20 @@
 {"Virtual Hosts", " "}.
 {"ejabberd virtual hosts", "  ejabberd"}.
 {"Host", ""}.
+{"Users Messages", " "}.
+{"Date", ""}.
+{"Count", ""}.
+{"Logged messages for ", " c  "}.
+{" at ", "  "}.
+{"No logged messages for ", "   "}.
+{"Date, Time", ", "}.
+{"Direction: Jid", ": Jid"}.
+{"Subject", ""}.
+{"Body", ""}.
+{"Messages", ""}.
+{"Filter Selected", " "}.
+{"Do Not Log Messages", "  "}.
+{"Log Messages", " "}.
 
 % Local Variables:
 % mode: erlang
--- msgs/nl-1.1.2.msg	Thu Apr 26 16:04:49 2007
+++ msgs/nl.msg	Thu Apr 26 16:04:49 2007
@@ -331,4 +331,15 @@
 {"Members:", "Groepsleden:"}.
 {"Displayed Groups:", "Weergegeven groepen:"}.
 {"Group ", "Groep "}.
+{"Users Messages", "Gebruikersberichten"}.
+{"Date", "Datum"}.
+{"Count", "Aantal"}.
+{"Logged messages for ", "Gelogde berichten van "}.
+{" at ", " op "}.
+{"No logged messages for ", "Geen gelogde berichten van "}.
+{"Date, Time", "Datum en tijd"}.
+{"Direction: Jid", "Richting: Jabber ID"}.
+{"Subject", "Onderwerp"}.
+{"Body", "Berichtveld"}.
+{"Messages", "Berichten"}.
 
